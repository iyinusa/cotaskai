/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/dexie-cloud-addon@4.0.11/dist/modern/dexie-cloud-addon.min.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import e, { PropModification as t, liveQuery as n, cmp as r } from "/npm/dexie@4.0.11/+esm"; import { BehaviorSubject as o, fromEvent as i, of as s, merge as a, Subject as u, combineLatest as c, firstValueFrom as l, from as d, throwError as f, Observable as h, Subscription as p, map as y, filter as v, share as m, timer as b } from "/npm/rxjs@7.8.1/+esm"; var g = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, _ = [], w = [], S = "undefined" != typeof Uint8Array ? Uint8Array : Array, k = !1; function E() { k = !0; for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0; t < 64; ++t)_[t] = e[t], w[e.charCodeAt(t)] = t; w["-".charCodeAt(0)] = 62, w["_".charCodeAt(0)] = 63 } function I(e, t, n) { for (var r, o, i = [], s = t; s < n; s += 3)r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], i.push(_[(o = r) >> 18 & 63] + _[o >> 12 & 63] + _[o >> 6 & 63] + _[63 & o]); return i.join("") } function x(e) { var t; k || E(); for (var n = e.length, r = n % 3, o = "", i = [], s = 16383, a = 0, u = n - r; a < u; a += s)i.push(I(e, a, a + s > u ? u : a + s)); return 1 === r ? (t = e[n - 1], o += _[t >> 2], o += _[t << 4 & 63], o += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o += _[t >> 10], o += _[t >> 4 & 63], o += _[t << 2 & 63], o += "="), i.push(o), i.join("") } function A(e, t, n, r, o) { var i, s, a = 8 * o - r - 1, u = (1 << a) - 1, c = u >> 1, l = -7, d = n ? o - 1 : 0, f = n ? -1 : 1, h = e[t + d]; for (d += f, i = h & (1 << -l) - 1, h >>= -l, l += a; l > 0; i = 256 * i + e[t + d], d += f, l -= 8); for (s = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; s = 256 * s + e[t + d], d += f, l -= 8); if (0 === i) i = 1 - c; else { if (i === u) return s ? NaN : 1 / 0 * (h ? -1 : 1); s += Math.pow(2, r), i -= c } return (h ? -1 : 1) * s * Math.pow(2, i - r) } function T(e, t, n, r, o, i) { var s, a, u, c = 8 * i - o - 1, l = (1 << c) - 1, d = l >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r ? 0 : i - 1, p = r ? 1 : -1, y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + d >= 1 ? f / u : f * Math.pow(2, 1 - d)) * u >= 2 && (s++, u /= 2), s + d >= l ? (a = 0, s = l) : s + d >= 1 ? (a = (t * u - 1) * Math.pow(2, o), s += d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, o), s = 0)); o >= 8; e[n + h] = 255 & a, h += p, a /= 256, o -= 8); for (s = s << o | a, c += o; c > 0; e[n + h] = 255 & s, h += p, s /= 256, c -= 8); e[n + h - p] |= 128 * y } var O = {}.toString, P = Array.isArray || function (e) { return "[object Array]" == O.call(e) }; function C() { return R.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function U(e, t) { if (C() < t) throw new RangeError("Invalid typed array length"); return R.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = R.prototype : (null === e && (e = new R(t)), e.length = t), e } function R(e, t, n) { if (!(R.TYPED_ARRAY_SUPPORT || this instanceof R)) return new R(e, t, n); if ("number" == typeof e) { if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string"); return D(this, e) } return j(this, e, t, n) } function j(e, t, n, r) { if ("number" == typeof t) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, n, r) { if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r); R.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = R.prototype : e = $(e, t); return e }(e, t, n, r) : "string" == typeof t ? function (e, t, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!R.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | M(t, n); e = U(e, r); var o = e.write(t, n); o !== r && (e = e.slice(0, o)); return e }(e, t, n) : function (e, t) { if (B(t)) { var n = 0 | N(t.length); return 0 === (e = U(e, n)).length || t.copy(e, 0, 0, n), e } if (t) { if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (r = t.length) != r ? U(e, 0) : $(e, t); if ("Buffer" === t.type && P(t.data)) return $(e, t.data) } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(e, t) } function L(e) { if ("number" != typeof e) throw new TypeError('"size" argument must be a number'); if (e < 0) throw new RangeError('"size" argument must not be negative') } function D(e, t) { if (L(t), e = U(e, t < 0 ? 0 : 0 | N(t)), !R.TYPED_ARRAY_SUPPORT) for (var n = 0; n < t; ++n)e[n] = 0; return e } function $(e, t) { var n = t.length < 0 ? 0 : 0 | N(t.length); e = U(e, n); for (var r = 0; r < n; r += 1)e[r] = 255 & t[r]; return e } function N(e) { if (e >= C()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + C().toString(16) + " bytes"); return 0 | e } function B(e) { return !(null == e || !e._isBuffer) } function M(e, t) { if (B(e)) return e.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength; "string" != typeof e && (e = "" + e); var n = e.length; if (0 === n) return 0; for (var r = !1; ;)switch (t) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return he(e).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return pe(e).length; default: if (r) return he(e).length; t = ("" + t).toLowerCase(), r = !0 } } function W(e, t, n) { var r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (t >>>= 0)) return ""; for (e || (e = "utf8"); ;)switch (e) { case "hex": return ne(this, t, n); case "utf8": case "utf-8": return X(this, t, n); case "ascii": return ee(this, t, n); case "latin1": case "binary": return te(this, t, n); case "base64": return Z(this, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return re(this, t, n); default: if (r) throw new TypeError("Unknown encoding: " + e); e = (e + "").toLowerCase(), r = !0 } } function F(e, t, n) { var r = e[t]; e[t] = e[n], e[n] = r } function Y(e, t, n, r, o) { if (0 === e.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) { if (o) return -1; n = e.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof t && (t = R.from(t, r)), B(t)) return 0 === t.length ? -1 : K(e, t, n, r, o); if ("number" == typeof t) return t &= 255, R.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : K(e, [t], n, r, o); throw new TypeError("val must be string, number or Buffer") } function K(e, t, n, r, o) { var i, s = 1, a = e.length, u = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (e.length < 2 || t.length < 2) return -1; s = 2, a /= 2, u /= 2, n /= 2 } function c(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s) } if (o) { var l = -1; for (i = n; i < a; i++)if (c(e, i) === c(t, -1 === l ? 0 : i - l)) { if (-1 === l && (l = i), i - l + 1 === u) return l * s } else -1 !== l && (i -= i - l), l = -1 } else for (n + u > a && (n = a - u), i = n; i >= 0; i--) { for (var d = !0, f = 0; f < u; f++)if (c(e, i + f) !== c(t, f)) { d = !1; break } if (d) return i } return -1 } function z(e, t, n, r) { n = Number(n) || 0; var o = e.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; var i = t.length; if (i % 2 != 0) throw new TypeError("Invalid hex string"); r > i / 2 && (r = i / 2); for (var s = 0; s < r; ++s) { var a = parseInt(t.substr(2 * s, 2), 16); if (isNaN(a)) return s; e[n + s] = a } return s } function H(e, t, n, r) { return ye(he(t, e.length - n), e, n, r) } function V(e, t, n, r) { return ye(function (e) { for (var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n)); return t }(t), e, n, r) } function q(e, t, n, r) { return V(e, t, n, r) } function J(e, t, n, r) { return ye(pe(t), e, n, r) } function G(e, t, n, r) { return ye(function (e, t) { for (var n, r, o, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)r = (n = e.charCodeAt(s)) >> 8, o = n % 256, i.push(o), i.push(r); return i }(t, e.length - n), e, n, r) } function Z(e, t, n) { return 0 === t && n === e.length ? x(e) : x(e.slice(t, n)) } function X(e, t, n) { n = Math.min(e.length, n); for (var r = [], o = t; o < n;) { var i, s, a, u, c = e[o], l = null, d = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (o + d <= n) switch (d) { case 1: c < 128 && (l = c); break; case 2: 128 == (192 & (i = e[o + 1])) && (u = (31 & c) << 6 | 63 & i) > 127 && (l = u); break; case 3: i = e[o + 1], s = e[o + 2], 128 == (192 & i) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (l = u); break; case 4: i = e[o + 1], s = e[o + 2], a = e[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & a) > 65535 && u < 1114112 && (l = u) }null === l ? (l = 65533, d = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), o += d } return function (e) { var t = e.length; if (t <= Q) return String.fromCharCode.apply(String, e); var n = "", r = 0; for (; r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += Q)); return n }(r) } R.TYPED_ARRAY_SUPPORT = void 0 === g.TYPED_ARRAY_SUPPORT || g.TYPED_ARRAY_SUPPORT, C(), R.poolSize = 8192, R._augment = function (e) { return e.__proto__ = R.prototype, e }, R.from = function (e, t, n) { return j(null, e, t, n) }, R.TYPED_ARRAY_SUPPORT && (R.prototype.__proto__ = Uint8Array.prototype, R.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && R[Symbol.species]), R.alloc = function (e, t, n) { return function (e, t, n, r) { return L(t), t <= 0 ? U(e, t) : void 0 !== n ? "string" == typeof r ? U(e, t).fill(n, r) : U(e, t).fill(n) : U(e, t) }(null, e, t, n) }, R.allocUnsafe = function (e) { return D(null, e) }, R.allocUnsafeSlow = function (e) { return D(null, e) }, R.isBuffer = function (e) { return null != e && (!!e._isBuffer || ve(e) || function (e) { return "function" == typeof e.readFloatLE && "function" == typeof e.slice && ve(e.slice(0, 0)) }(e)) }, R.compare = function (e, t) { if (!B(e) || !B(t)) throw new TypeError("Arguments must be Buffers"); if (e === t) return 0; for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)if (e[o] !== t[o]) { n = e[o], r = t[o]; break } return n < r ? -1 : r < n ? 1 : 0 }, R.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, R.concat = function (e, t) { if (!P(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length) return R.alloc(0); var n; if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n)t += e[n].length; var r = R.allocUnsafe(t), o = 0; for (n = 0; n < e.length; ++n) { var i = e[n]; if (!B(i)) throw new TypeError('"list" argument must be an Array of Buffers'); i.copy(r, o), o += i.length } return r }, R.byteLength = M, R.prototype._isBuffer = !0, R.prototype.swap16 = function () { var e = this.length; if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; t < e; t += 2)F(this, t, t + 1); return this }, R.prototype.swap32 = function () { var e = this.length; if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; t < e; t += 4)F(this, t, t + 3), F(this, t + 1, t + 2); return this }, R.prototype.swap64 = function () { var e = this.length; if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var t = 0; t < e; t += 8)F(this, t, t + 7), F(this, t + 1, t + 6), F(this, t + 2, t + 5), F(this, t + 3, t + 4); return this }, R.prototype.toString = function () { var e = 0 | this.length; return 0 === e ? "" : 0 === arguments.length ? X(this, 0, e) : W.apply(this, arguments) }, R.prototype.equals = function (e) { if (!B(e)) throw new TypeError("Argument must be a Buffer"); return this === e || 0 === R.compare(this, e) }, R.prototype.inspect = function () { var e = ""; return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">" }, R.prototype.compare = function (e, t, n, r, o) { if (!B(e)) throw new TypeError("Argument must be a Buffer"); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length) throw new RangeError("out of range index"); if (r >= o && t >= n) return 0; if (r >= o) return -1; if (t >= n) return 1; if (this === e) return 0; for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(i, s), u = this.slice(r, o), c = e.slice(t, n), l = 0; l < a; ++l)if (u[l] !== c[l]) { i = u[l], s = c[l]; break } return i < s ? -1 : s < i ? 1 : 0 }, R.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n) }, R.prototype.indexOf = function (e, t, n) { return Y(this, e, t, n, !0) }, R.prototype.lastIndexOf = function (e, t, n) { return Y(this, e, t, n, !1) }, R.prototype.write = function (e, t, n, r) { if (void 0 === t) r = "utf8", n = this.length, t = 0; else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0; else { if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var o = this.length - t; if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var i = !1; ;)switch (r) { case "hex": return z(this, e, t, n); case "utf8": case "utf-8": return H(this, e, t, n); case "ascii": return V(this, e, t, n); case "latin1": case "binary": return q(this, e, t, n); case "base64": return J(this, e, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return G(this, e, t, n); default: if (i) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), i = !0 } }, R.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var Q = 4096; function ee(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)r += String.fromCharCode(127 & e[o]); return r } function te(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)r += String.fromCharCode(e[o]); return r } function ne(e, t, n) { var r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); for (var o = "", i = t; i < n; ++i)o += fe(e[i]); return o } function re(e, t, n) { for (var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2)o += String.fromCharCode(r[i] + 256 * r[i + 1]); return o } function oe(e, t, n) { if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint"); if (e + t > n) throw new RangeError("Trying to access beyond buffer length") } function ie(e, t, n, r, o, i) { if (!B(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i) throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length) throw new RangeError("Index out of range") } function se(e, t, n, r) { t < 0 && (t = 65535 + t + 1); for (var o = 0, i = Math.min(e.length - n, 2); o < i; ++o)e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o) } function ae(e, t, n, r) { t < 0 && (t = 4294967295 + t + 1); for (var o = 0, i = Math.min(e.length - n, 4); o < i; ++o)e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255 } function ue(e, t, n, r, o, i) { if (n + r > e.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function ce(e, t, n, r, o) { return o || ue(e, 0, n, 4), T(e, t, n, r, 23, 4), n + 4 } function le(e, t, n, r, o) { return o || ue(e, 0, n, 8), T(e, t, n, r, 52, 8), n + 8 } R.prototype.slice = function (e, t) { var n, r = this.length; if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), R.TYPED_ARRAY_SUPPORT) (n = this.subarray(e, t)).__proto__ = R.prototype; else { var o = t - e; n = new R(o, void 0); for (var i = 0; i < o; ++i)n[i] = this[i + e] } return n }, R.prototype.readUIntLE = function (e, t, n) { e |= 0, t |= 0, n || oe(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o; return r }, R.prototype.readUIntBE = function (e, t, n) { e |= 0, t |= 0, n || oe(e, t, this.length); for (var r = this[e + --t], o = 1; t > 0 && (o *= 256);)r += this[e + --t] * o; return r }, R.prototype.readUInt8 = function (e, t) { return t || oe(e, 1, this.length), this[e] }, R.prototype.readUInt16LE = function (e, t) { return t || oe(e, 2, this.length), this[e] | this[e + 1] << 8 }, R.prototype.readUInt16BE = function (e, t) { return t || oe(e, 2, this.length), this[e] << 8 | this[e + 1] }, R.prototype.readUInt32LE = function (e, t) { return t || oe(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, R.prototype.readUInt32BE = function (e, t) { return t || oe(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, R.prototype.readIntLE = function (e, t, n) { e |= 0, t |= 0, n || oe(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o; return r >= (o *= 128) && (r -= Math.pow(2, 8 * t)), r }, R.prototype.readIntBE = function (e, t, n) { e |= 0, t |= 0, n || oe(e, t, this.length); for (var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);)i += this[e + --r] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i }, R.prototype.readInt8 = function (e, t) { return t || oe(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, R.prototype.readInt16LE = function (e, t) { t || oe(e, 2, this.length); var n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n }, R.prototype.readInt16BE = function (e, t) { t || oe(e, 2, this.length); var n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n }, R.prototype.readInt32LE = function (e, t) { return t || oe(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, R.prototype.readInt32BE = function (e, t) { return t || oe(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, R.prototype.readFloatLE = function (e, t) { return t || oe(e, 4, this.length), A(this, e, !0, 23, 4) }, R.prototype.readFloatBE = function (e, t) { return t || oe(e, 4, this.length), A(this, e, !1, 23, 4) }, R.prototype.readDoubleLE = function (e, t) { return t || oe(e, 8, this.length), A(this, e, !0, 52, 8) }, R.prototype.readDoubleBE = function (e, t) { return t || oe(e, 8, this.length), A(this, e, !1, 52, 8) }, R.prototype.writeUIntLE = function (e, t, n, r) { (e = +e, t |= 0, n |= 0, r) || ie(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = 1, i = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)this[t + i] = e / o & 255; return t + n }, R.prototype.writeUIntBE = function (e, t, n, r) { (e = +e, t |= 0, n |= 0, r) || ie(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = n - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)this[t + o] = e / i & 255; return t + n }, R.prototype.writeUInt8 = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 1, 255, 0), R.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1 }, R.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 2, 65535, 0), R.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : se(this, e, t, !0), t + 2 }, R.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 2, 65535, 0), R.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : se(this, e, t, !1), t + 2 }, R.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 4, 4294967295, 0), R.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : ae(this, e, t, !0), t + 4 }, R.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 4, 4294967295, 0), R.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : ae(this, e, t, !1), t + 4 }, R.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t |= 0, !r) { var o = Math.pow(2, 8 * n - 1); ie(this, e, t, n, o - 1, -o) } var i = 0, s = 1, a = 0; for (this[t] = 255 & e; ++i < n && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + i - 1] && (a = 1), this[t + i] = (e / s | 0) - a & 255; return t + n }, R.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t |= 0, !r) { var o = Math.pow(2, 8 * n - 1); ie(this, e, t, n, o - 1, -o) } var i = n - 1, s = 1, a = 0; for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + i + 1] && (a = 1), this[t + i] = (e / s | 0) - a & 255; return t + n }, R.prototype.writeInt8 = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 1, 127, -128), R.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, R.prototype.writeInt16LE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 2, 32767, -32768), R.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : se(this, e, t, !0), t + 2 }, R.prototype.writeInt16BE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 2, 32767, -32768), R.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : se(this, e, t, !1), t + 2 }, R.prototype.writeInt32LE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 4, 2147483647, -2147483648), R.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : ae(this, e, t, !0), t + 4 }, R.prototype.writeInt32BE = function (e, t, n) { return e = +e, t |= 0, n || ie(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), R.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : ae(this, e, t, !1), t + 4 }, R.prototype.writeFloatLE = function (e, t, n) { return ce(this, e, t, !0, n) }, R.prototype.writeFloatBE = function (e, t, n) { return ce(this, e, t, !1, n) }, R.prototype.writeDoubleLE = function (e, t, n) { return le(this, e, t, !0, n) }, R.prototype.writeDoubleBE = function (e, t, n) { return le(this, e, t, !1, n) }, R.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === e.length || 0 === this.length) return 0; if (t < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); var o, i = r - n; if (this === e && n < t && t < r) for (o = i - 1; o >= 0; --o)e[o + t] = this[o + n]; else if (i < 1e3 || !R.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o)e[o + t] = this[o + n]; else Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t); return i }, R.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) { if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) { var o = e.charCodeAt(0); o < 256 && (e = o) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !R.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof e && (e &= 255); if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index"); if (n <= t) return this; var i; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e) for (i = t; i < n; ++i)this[i] = e; else { var s = B(e) ? e : he(new R(e, r).toString()), a = s.length; for (i = 0; i < n - t; ++i)this[i + t] = s[i % a] } return this }; var de = /[^+\/0-9A-Za-z-_]/g; function fe(e) { return e < 16 ? "0" + e.toString(16) : e.toString(16) } function he(e, t) { var n; t = t || 1 / 0; for (var r = e.length, o = null, i = [], s = 0; s < r; ++s) { if ((n = e.charCodeAt(s)) > 55295 && n < 57344) { if (!o) { if (n > 56319) { (t -= 3) > -1 && i.push(239, 191, 189); continue } if (s + 1 === r) { (t -= 3) > -1 && i.push(239, 191, 189); continue } o = n; continue } if (n < 56320) { (t -= 3) > -1 && i.push(239, 191, 189), o = n; continue } n = 65536 + (o - 55296 << 10 | n - 56320) } else o && (t -= 3) > -1 && i.push(239, 191, 189); if (o = null, n < 128) { if ((t -= 1) < 0) break; i.push(n) } else if (n < 2048) { if ((t -= 2) < 0) break; i.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((t -= 3) < 0) break; i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((t -= 4) < 0) break; i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return i } function pe(e) { return function (e) { var t, n, r, o, i, s; k || E(); var a = e.length; if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); i = "=" === e[a - 2] ? 2 : "=" === e[a - 1] ? 1 : 0, s = new S(3 * a / 4 - i), r = i > 0 ? a - 4 : a; var u = 0; for (t = 0, n = 0; t < r; t += 4, n += 3)o = w[e.charCodeAt(t)] << 18 | w[e.charCodeAt(t + 1)] << 12 | w[e.charCodeAt(t + 2)] << 6 | w[e.charCodeAt(t + 3)], s[u++] = o >> 16 & 255, s[u++] = o >> 8 & 255, s[u++] = 255 & o; return 2 === i ? (o = w[e.charCodeAt(t)] << 2 | w[e.charCodeAt(t + 1)] >> 4, s[u++] = 255 & o) : 1 === i && (o = w[e.charCodeAt(t)] << 10 | w[e.charCodeAt(t + 1)] << 4 | w[e.charCodeAt(t + 2)] >> 2, s[u++] = o >> 8 & 255, s[u++] = 255 & o), s }(function (e) { if ((e = function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") }(e).replace(de, "")).length < 2) return ""; for (; e.length % 4 != 0;)e += "="; return e }(e)) } function ye(e, t, n, r) { for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)t[o + n] = e[o]; return o } function ve(e) { return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) } var me = function (e, t) { return me = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, me(e, t) }; function be(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function n() { this.constructor = e } me(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) } function ge(e, t, n, r) { return new (n || (n = Promise))((function (o, i) { function s(e) { try { u(r.next(e)) } catch (e) { i(e) } } function a(e) { try { u(r.throw(e)) } catch (e) { i(e) } } function u(e) { var t; e.done ? o(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } u((r = r.apply(e, t || [])).next()) })) } function _e(e, t) { var n, r, o, i, s = { label: 0, sent: function () { if (1 & o[0]) throw o[1]; return o[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function () { return this }), i; function a(i) { return function (a) { return function (i) { if (n) throw new TypeError("Generator is already executing."); for (; s;)try { if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o; switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) { case 0: case 1: o = i; break; case 4: return s.label++, { value: i[1], done: !1 }; case 5: s.label++, r = i[1], i = [0]; continue; case 7: i = s.ops.pop(), s.trys.pop(); continue; default: if (!((o = (o = s.trys).length > 0 && o[o.length - 1]) || 6 !== i[0] && 2 !== i[0])) { s = 0; continue } if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) { s.label = i[1]; break } if (6 === i[0] && s.label < o[1]) { s.label = o[1], o = i; break } if (o && s.label < o[2]) { s.label = o[2], s.ops.push(i); break } o[2] && s.ops.pop(), s.trys.pop(); continue }i = t.call(e, s) } catch (e) { i = [6, e], r = 0 } finally { n = o = 0 } if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } }([i, a]) } } } function we(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function Se(e, t) { var n = "function" == typeof Symbol && e[Symbol.iterator]; if (!n) return e; var r, o, i = n.call(e), s = []; try { for (; (void 0 === t || t-- > 0) && !(r = i.next()).done;)s.push(r.value) } catch (e) { o = { error: e } } finally { try { r && !r.done && (n = i.return) && n.call(i) } finally { if (o) throw o.error } } return s } function ke(e, t, n) { if (n || 2 === arguments.length) for (var r, o = 0, i = t.length; o < i; o++)!r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)), r[o] = t[o]); return e.concat(r || Array.prototype.slice.call(t)) } function Ee(e) { return this instanceof Ee ? (this.v = e, this) : new Ee(e) } function Ie(e) { if (!e) throw new Error("Assertion Failed") } const xe = {}.hasOwnProperty; function Ae(e, t, n) { if (e && void 0 !== t && (!("isFrozen" in Object) || !Object.isFrozen(e))) if ("string" != typeof t && "length" in t) { Ie("string" != typeof n && "length" in n); for (var r = 0, o = t.length; r < o; ++r)Ae(e, t[r], n[r]) } else { var i = t.indexOf("."); if (-1 !== i) { var s = t.substr(0, i), a = t.substr(i + 1); if ("" === a) void 0 === n ? Array.isArray(e) ? isNaN(parseInt(s)) || e.splice(parseInt(s), 1) : delete e[s] : e[s] = n; else { var u = e[s]; u && function (e, t) { return xe.call(e, t) }(e, s) || (u = e[s] = {}), Ae(u, a, n) } } else void 0 === n ? Array.isArray(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = n } } const Te = "undefined" != typeof self && "undefined" != typeof crypto ? (e, t = crypto.getRandomValues.bind(crypto)) => { const n = new Uint8Array(e); return t(n), self.btoa(String.fromCharCode.apply(null, n)) } : void 0 !== R ? (e, t = Oe) => { const n = R.alloc(e); return t(n), n.toString("base64") } : () => { throw new Error("No implementation of randomString was found") }; function Oe(e) { for (let t = 0; t < e.length; ++t)e[t] = Math.floor(256 * Math.random()) } function Pe(e) { return "string" == typeof e || !!(Array.isArray(e) && e.some((e => Pe(e))) && e.every(Ce)) } function Ce(e) { return "string" == typeof e || "number" == typeof e || Array.isArray(e) && e.every(Ce) } function Ue(e, t, n) { const r = e[t] || (e[t] = {}), o = n.keys.map((e => "string" == typeof e ? e : JSON.stringify(e))); switch (n.type) { case "insert": case "upsert": o.forEach(((e, t) => { r[e] = { type: "ups", val: n.values[t] } })); break; case "update": case "modify": o.forEach(((e, t) => { const o = "update" === n.type ? n.changeSpecs[t] : n.changeSpec, i = r[e]; if (i) switch (i.type) { case "ups": for (const [e, t] of Object.entries(o)) Ae(i.val, e, t); break; case "del": break; case "upd": Object.assign(i.mod, o) } else r[e] = { type: "upd", mod: o } })); break; case "delete": o.forEach((e => { r[e] = { type: "del" } })) }return e } function Re(e, t) { for (const { table: n, muts: r } of t) for (const t of r) Ue(e, n, t) } function je(e) { return "function" == typeof e } function Le(e) { return function (t) { if (function (e) { return je(null == e ? void 0 : e.lift) }(t)) return t.lift((function (t) { try { return e(t, this) } catch (e) { this.error(e) } })); throw new TypeError("Unable to lift unknown Observable type") } } var De = function (e) { return e && "number" == typeof e.length && "function" != typeof e }; function $e(e) { return je(null == e ? void 0 : e.then) } var Ne, Be, Me = (Ne = function (e) { return function (t) { e(this), this.message = t ? t.length + " errors occurred during unsubscription:\n" + t.map((function (e, t) { return t + 1 + ") " + e.toString() })).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t } }, (Be = Ne((function (e) { Error.call(e), e.stack = (new Error).stack }))).prototype = Object.create(Error.prototype), Be.prototype.constructor = Be, Be); function We(e, t) { if (e) { var n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } var Fe = function () { function e(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } var t; return e.prototype.unsubscribe = function () { var e, t, n, r, o; if (!this.closed) { this.closed = !0; var i = this._parentage; if (i) if (this._parentage = null, Array.isArray(i)) try { for (var s = we(i), a = s.next(); !a.done; a = s.next())a.value.remove(this) } catch (t) { e = { error: t } } finally { try { a && !a.done && (t = s.return) && t.call(s) } finally { if (e) throw e.error } } else i.remove(this); var u = this.initialTeardown; if (je(u)) try { u() } catch (e) { o = e instanceof Me ? e.errors : [e] } var c = this._finalizers; if (c) { this._finalizers = null; try { for (var l = we(c), d = l.next(); !d.done; d = l.next()) { var f = d.value; try { Ke(f) } catch (e) { o = null != o ? o : [], e instanceof Me ? o = ke(ke([], Se(o)), Se(e.errors)) : o.push(e) } } } catch (e) { n = { error: e } } finally { try { d && !d.done && (r = l.return) && r.call(l) } finally { if (n) throw n.error } } } if (o) throw new Me(o) } }, e.prototype.add = function (t) { var n; if (t && t !== this) if (this.closed) Ke(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } }, e.prototype._hasParent = function (e) { var t = this._parentage; return t === e || Array.isArray(t) && t.includes(e) }, e.prototype._addParent = function (e) { var t = this._parentage; this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e }, e.prototype._removeParent = function (e) { var t = this._parentage; t === e ? this._parentage = null : Array.isArray(t) && We(t, e) }, e.prototype.remove = function (t) { var n = this._finalizers; n && We(n, t), t instanceof e && t._removeParent(this) }, e.EMPTY = ((t = new e).closed = !0, t), e }(); function Ye(e) { return e instanceof Fe || e && "closed" in e && je(e.remove) && je(e.add) && je(e.unsubscribe) } function Ke(e) { je(e) ? e() : e.unsubscribe() } Fe.EMPTY; var ze = void 0, He = !1, Ve = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; return setTimeout.apply(void 0, ke([e, t], Se(n))) }; function qe(e) { Ve((function () { throw e })) } function Je() { } var Ge = function (e) { function t(t) { var n = e.call(this) || this; return n.isStopped = !1, t ? (n.destination = t, Ye(t) && t.add(n)) : n.destination = nt, n } return be(t, e), t.create = function (e, t, n) { return new et(e, t, n) }, t.prototype.next = function (e) { this.isStopped || this._next(e) }, t.prototype.error = function (e) { this.isStopped || (this.isStopped = !0, this._error(e)) }, t.prototype.complete = function () { this.isStopped || (this.isStopped = !0, this._complete()) }, t.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null) }, t.prototype._next = function (e) { this.destination.next(e) }, t.prototype._error = function (e) { try { this.destination.error(e) } finally { this.unsubscribe() } }, t.prototype._complete = function () { try { this.destination.complete() } finally { this.unsubscribe() } }, t }(Fe), Ze = Function.prototype.bind; function Xe(e, t) { return Ze.call(e, t) } var Qe = function () { function e(e) { this.partialObserver = e } return e.prototype.next = function (e) { var t = this.partialObserver; if (t.next) try { t.next(e) } catch (e) { tt(e) } }, e.prototype.error = function (e) { var t = this.partialObserver; if (t.error) try { t.error(e) } catch (e) { tt(e) } else tt(e) }, e.prototype.complete = function () { var e = this.partialObserver; if (e.complete) try { e.complete() } catch (e) { tt(e) } }, e }(), et = function (e) { function t(t, n, r) { var o, i, s = e.call(this) || this; return je(t) || !t ? o = { next: null != t ? t : void 0, error: null != n ? n : void 0, complete: null != r ? r : void 0 } : s && He ? ((i = Object.create(t)).unsubscribe = function () { return s.unsubscribe() }, o = { next: t.next && Xe(t.next, i), error: t.error && Xe(t.error, i), complete: t.complete && Xe(t.complete, i) }) : o = t, s.destination = new Qe(o), s } return be(t, e), t }(Ge); function tt(e) { qe(e) } var nt = { closed: !0, next: Je, error: function (e) { throw e }, complete: Je }, rt = "function" == typeof Symbol && Symbol.observable || "@@observable"; function ot(e) { return e } var it = function () { function e(e) { e && (this._subscribe = e) } return e.prototype.lift = function (t) { var n = new e; return n.source = this, n.operator = t, n }, e.prototype.subscribe = function (e, t, n) { var r, o = this, i = (r = e) && r instanceof Ge || function (e) { return e && je(e.next) && je(e.error) && je(e.complete) }(r) && Ye(r) ? e : new et(e, t, n); return function () { var e = o, t = e.operator, n = e.source; i.add(t ? t.call(i, n) : n ? o._subscribe(i) : o._trySubscribe(i)) }(), i }, e.prototype._trySubscribe = function (e) { try { return this._subscribe(e) } catch (t) { e.error(t) } }, e.prototype.forEach = function (e, t) { var n = this; return new (t = st(t))((function (t, r) { var o = new et({ next: function (t) { try { e(t) } catch (e) { r(e), o.unsubscribe() } }, error: r, complete: t }); n.subscribe(o) })) }, e.prototype._subscribe = function (e) { var t; return null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(e) }, e.prototype[rt] = function () { return this }, e.prototype.pipe = function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return (0 === (e = t).length ? ot : 1 === e.length ? e[0] : function (t) { return e.reduce((function (e, t) { return t(e) }), t) })(this) }, e.prototype.toPromise = function (e) { var t = this; return new (e = st(e))((function (e, n) { var r; t.subscribe((function (e) { return r = e }), (function (e) { return n(e) }), (function () { return e(r) })) })) }, e.create = function (t) { return new e(t) }, e }(); function st(e) { var t; return null !== (t = null != e ? e : ze) && void 0 !== t ? t : Promise } function at(e) { return je(e[rt]) } function ut(e) { return Symbol.asyncIterator && je(null == e ? void 0 : e[Symbol.asyncIterator]) } function ct(e) { return new TypeError("You provided " + (null !== e && "object" == typeof e ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.") } var lt = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"; function dt(e) { return je(null == e ? void 0 : e[lt]) } function ft(e) { return function (e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r, o = n.apply(e, t || []), i = []; return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function () { return this }, r; function s(e) { o[e] && (r[e] = function (t) { return new Promise((function (n, r) { i.push([e, t, n, r]) > 1 || a(e, t) })) }) } function a(e, t) { try { !function (e) { e.value instanceof Ee ? Promise.resolve(e.value.v).then(u, c) : l(i[0][2], e) }(o[e](t)) } catch (e) { l(i[0][3], e) } } function u(e) { a("next", e) } function c(e) { a("throw", e) } function l(e, t) { e(t), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, (function () { var t, n, r; return _e(this, (function (o) { switch (o.label) { case 0: t = e.getReader(), o.label = 1; case 1: o.trys.push([1, , 9, 10]), o.label = 2; case 2: return [4, Ee(t.read())]; case 3: return n = o.sent(), r = n.value, n.done ? [4, Ee(void 0)] : [3, 5]; case 4: return [2, o.sent()]; case 5: return [4, Ee(r)]; case 6: return [4, o.sent()]; case 7: return o.sent(), [3, 2]; case 8: return [3, 10]; case 9: return t.releaseLock(), [7]; case 10: return [2] } })) })) } function ht(e) { return je(null == e ? void 0 : e.getReader) } function pt(e) { if (e instanceof it) return e; if (null != e) { if (at(e)) return o = e, new it((function (e) { var t = o[rt](); if (je(t.subscribe)) return t.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") })); if (De(e)) return r = e, new it((function (e) { for (var t = 0; t < r.length && !e.closed; t++)e.next(r[t]); e.complete() })); if ($e(e)) return n = e, new it((function (e) { n.then((function (t) { e.closed || (e.next(t), e.complete()) }), (function (t) { return e.error(t) })).then(null, qe) })); if (ut(e)) return yt(e); if (dt(e)) return t = e, new it((function (e) { var n, r; try { for (var o = we(t), i = o.next(); !i.done; i = o.next()) { var s = i.value; if (e.next(s), e.closed) return } } catch (e) { n = { error: e } } finally { try { i && !i.done && (r = o.return) && r.call(o) } finally { if (n) throw n.error } } e.complete() })); if (ht(e)) return yt(ft(e)) } var t, n, r, o; throw ct(e) } function yt(e) { return new it((function (t) { (function (e, t) { var n, r, o, i; return ge(this, void 0, void 0, (function () { var s, a; return _e(this, (function (u) { switch (u.label) { case 0: u.trys.push([0, 5, 6, 11]), n = function (e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = we(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this }, t); function r(n) { t[n] = e[n] && function (t) { return new Promise((function (r, o) { !function (e, t, n, r) { Promise.resolve(r).then((function (t) { e({ value: t, done: n }) }), t) }(r, o, (t = e[n](t)).done, t.value) })) } } }(e), u.label = 1; case 1: return [4, n.next()]; case 2: if ((r = u.sent()).done) return [3, 4]; if (s = r.value, t.next(s), t.closed) return [2]; u.label = 3; case 3: return [3, 1]; case 4: return [3, 11]; case 5: return a = u.sent(), o = { error: a }, [3, 11]; case 6: return u.trys.push([6, , 9, 10]), r && !r.done && (i = n.return) ? [4, i.call(n)] : [3, 8]; case 7: u.sent(), u.label = 8; case 8: return [3, 10]; case 9: if (o) throw o.error; return [7]; case 10: return [7]; case 11: return t.complete(), [2] } })) })) })(e, t).catch((function (e) { return t.error(e) })) })) } function vt(e, t, n, r, o) { return new mt(e, t, n, r, o) } var mt = function (e) { function t(t, n, r, o, i, s) { var a = e.call(this, t) || this; return a.onFinalize = i, a.shouldUnsubscribe = s, a._next = n ? function (e) { try { n(e) } catch (e) { t.error(e) } } : e.prototype._next, a._error = o ? function (e) { try { o(e) } catch (e) { t.error(e) } finally { this.unsubscribe() } } : e.prototype._error, a._complete = r ? function () { try { r() } catch (e) { t.error(e) } finally { this.unsubscribe() } } : e.prototype._complete, a } return be(t, e), t.prototype.unsubscribe = function () { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { var n = this.closed; e.prototype.unsubscribe.call(this), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } }, t }(Ge), bt = function (e) { function t(t, n) { return e.call(this) || this } return be(t, e), t.prototype.schedule = function (e, t) { return this }, t }(Fe), gt = { setInterval: function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var o = gt.delegate; return (null == o ? void 0 : o.setInterval) ? o.setInterval.apply(o, ke([e, t], Se(n))) : setInterval.apply(void 0, ke([e, t], Se(n))) }, clearInterval: function (e) { return clearInterval(e) }, delegate: void 0 }, _t = function (e) { function t(t, n) { var r = e.call(this, t, n) || this; return r.scheduler = t, r.work = n, r.pending = !1, r } return be(t, e), t.prototype.schedule = function (e, t) { if (void 0 === t && (t = 0), this.closed) return this; this.state = e; var n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, t)), this.pending = !0, this.delay = t, this.id = this.id || this.requestAsyncId(r, this.id, t), this }, t.prototype.requestAsyncId = function (e, t, n) { return void 0 === n && (n = 0), gt.setInterval(e.flush.bind(e, this), n) }, t.prototype.recycleAsyncId = function (e, t, n) { if (void 0 === n && (n = 0), null != n && this.delay === n && !1 === this.pending) return t; gt.clearInterval(t) }, t.prototype.execute = function (e, t) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; var n = this._execute(e, t); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) }, t.prototype._execute = function (e, t) { var n, r = !1; try { this.work(e) } catch (e) { r = !0, n = e || new Error("Scheduled action threw falsy error") } if (r) return this.unsubscribe(), n }, t.prototype.unsubscribe = function () { if (!this.closed) { var t = this.id, n = this.scheduler, r = n.actions; this.work = this.state = this.scheduler = null, this.pending = !1, We(r, this), null != t && (this.id = this.recycleAsyncId(n, t, null)), this.delay = null, e.prototype.unsubscribe.call(this) } }, t }(bt), wt = function () { return Date.now() }, St = function () { function e(t, n) { void 0 === n && (n = e.now), this.schedulerActionCtor = t, this.now = n } return e.prototype.schedule = function (e, t, n) { return void 0 === t && (t = 0), new this.schedulerActionCtor(this, e).schedule(n, t) }, e.now = wt, e }(), kt = new (function (e) { function t(t, n) { void 0 === n && (n = St.now); var r = e.call(this, t, n) || this; return r.actions = [], r._active = !1, r._scheduled = void 0, r } return be(t, e), t.prototype.flush = function (e) { var t = this.actions; if (this._active) t.push(e); else { var n; this._active = !0; do { if (n = e.execute(e.state, e.delay)) break } while (e = t.shift()); if (this._active = !1, n) { for (; e = t.shift();)e.unsubscribe(); throw n } } }, t }(St))(_t), Et = kt; function It(e) { return e && je(e.schedule) } function xt(e) { return It((t = e)[t.length - 1]) ? e.pop() : void 0; var t } function At(e, t, n, r, o) { void 0 === r && (r = 0), void 0 === o && (o = !1); var i = t.schedule((function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }), r); if (e.add(i), !o) return i } function Tt(e) { return Le((function (t, n) { var r, o = null, i = !1; o = t.subscribe(vt(n, void 0, void 0, (function (s) { r = pt(e(s, Tt(e)(t))), o ? (o.unsubscribe(), o = null, r.subscribe(n)) : i = !0 }))), i && (o.unsubscribe(), o = null, r.subscribe(n)) })) } function Ot(e, t) { return void 0 === t && (t = 0), Le((function (n, r) { n.subscribe(vt(r, (function (n) { return At(r, e, (function () { return r.next(n) }), t) }), (function () { return At(r, e, (function () { return r.complete() }), t) }), (function (n) { return At(r, e, (function () { return r.error(n) }), t) }))) })) } function Pt(e, t) { return void 0 === t && (t = 0), Le((function (n, r) { r.add(e.schedule((function () { return n.subscribe(r) }), t)) })) } function Ct(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new it((function (n) { At(n, t, (function () { var r = e[Symbol.asyncIterator](); At(n, t, (function () { r.next().then((function (e) { e.done ? n.complete() : n.next(e.value) })) }), 0, !0) })) })) } function Ut(e, t) { return Le((function (n, r) { var o = 0; n.subscribe(vt(r, (function (n) { r.next(e.call(t, n, o++)) }))) })) } function Rt(e, t, n) { return void 0 === n && (n = 1 / 0), je(t) ? Rt((function (n, r) { return Ut((function (e, o) { return t(n, e, r, o) }))(pt(e(n, r))) }), n) : ("number" == typeof t && (n = t), Le((function (t, r) { return function (e, t, n, r) { var o = [], i = 0, s = 0, a = !1, u = function () { !a || o.length || i || t.complete() }, c = function (e) { return i < r ? l(e) : o.push(e) }, l = function (e) { i++; var a = !1; pt(n(e, s++)).subscribe(vt(t, (function (e) { t.next(e) }), (function () { a = !0 }), void 0, (function () { if (a) try { i--; for (var e = function () { var e = o.shift(); l(e) }; o.length && i < r;)e(); u() } catch (e) { t.error(e) } }))) }; return e.subscribe(vt(t, c, (function () { a = !0, u() }))), function () { } }(t, r, e, n) }))) } function jt(e, t) { return void 0 === t && (t = kt), Le((function (n, r) { var o = null, i = null, s = null, a = function () { if (o) { o.unsubscribe(), o = null; var e = i; i = null, r.next(e) } }; function u() { var n = s + e, i = t.now(); if (i < n) return o = this.schedule(void 0, n - i), void r.add(o); a() } n.subscribe(vt(r, (function (n) { i = n, s = t.now(), o || (o = t.schedule(u, e), r.add(o)) }), (function () { a(), r.complete() }), void 0, (function () { i = o = null }))) })) } function Lt() { for (var e, t, n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r]; return function () { return void 0 === (e = 1) && (e = 1 / 0), Rt(ot, e); var e }()((e = n, (t = xt(n)) ? function (e, t) { if (null != e) { if (at(e)) return function (e, t) { return pt(e).pipe(Pt(t), Ot(t)) }(e, t); if (De(e)) return function (e, t) { return new it((function (n) { var r = 0; return t.schedule((function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) })) })) }(e, t); if ($e(e)) return function (e, t) { return pt(e).pipe(Pt(t), Ot(t)) }(e, t); if (ut(e)) return Ct(e, t); if (dt(e)) return function (e, t) { return new it((function (n) { var r; return At(n, t, (function () { r = e[lt](), At(n, t, (function () { var e, t, o; try { t = (e = r.next()).value, o = e.done } catch (e) { return void n.error(e) } o ? n.complete() : n.next(t) }), 0, !0) })), function () { return je(null == r ? void 0 : r.return) && r.return() } })) }(e, t); if (ht(e)) return function (e, t) { return Ct(ft(e), t) }(e, t) } throw ct(e) }(e, t) : pt(e))) } var Dt = new it((function (e) { return e.complete() })); function $t(e) { return e <= 0 ? function () { return Dt } : Le((function (t, n) { var r = 0; t.subscribe(vt(n, (function (t) { ++r <= e && (n.next(t), e <= r && n.complete()) }))) })) } function Nt(e, t) { return t ? function (n) { return Lt(t.pipe($t(1), Le((function (e, t) { e.subscribe(vt(t, Je)) }))), n.pipe(Nt(e))) } : Rt((function (t, n) { return e(t, n).pipe($t(1), function (e) { return Ut((function () { return e })) }(t)) })) } function Bt(e, t) { void 0 === t && (t = kt); var n = function (e, t, n) { void 0 === e && (e = 0), void 0 === n && (n = Et); var r = -1; return null != t && (It(t) ? n = t : r = t), new it((function (t) { var o, i = (o = e) instanceof Date && !isNaN(o) ? +e - n.now() : e; i < 0 && (i = 0); var s = 0; return n.schedule((function () { t.closed || (t.next(s++), 0 <= r ? this.schedule(void 0, r) : t.complete()) }), i) })) }(e, t); return Nt((function () { return n })) } function Mt(e, t) { return void 0 === t && (t = ot), e = null != e ? e : Wt, Le((function (n, r) { var o, i = !0; n.subscribe(vt(r, (function (n) { var s = t(n); !i && e(o, s) || (i = !1, o = s, r.next(n)) }))) })) } function Wt(e, t) { return e === t } function Ft(e, t) { return Le((function (n, r) { var o = 0; n.subscribe(vt(r, (function (n) { return e.call(t, n, o++) && r.next(n) }))) })) } function Yt(e) { return Ft((function (t, n) { return e <= n })) } function Kt() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; var n = xt(e); return Le((function (t, r) { (n ? Lt(e, t, n) : Lt(e, t)).subscribe(r) })) } function zt(e, t) { return Le((function (n, r) { var o = null, i = 0, s = !1, a = function () { return s && !o && r.complete() }; n.subscribe(vt(r, (function (n) { null == o || o.unsubscribe(); var s = 0, u = i++; pt(e(n, u)).subscribe(o = vt(r, (function (e) { return r.next(t ? t(n, e, u, s++) : e) }), (function () { o = null, a() }))) }), (function () { s = !0, a() }))) })) } function Ht(e, t, n) { var r = je(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? Le((function (e, t) { var n; null === (n = r.subscribe) || void 0 === n || n.call(r); var o = !0; e.subscribe(vt(t, (function (e) { var n; null === (n = r.next) || void 0 === n || n.call(r, e), t.next(e) }), (function () { var e; o = !1, null === (e = r.complete) || void 0 === e || e.call(r), t.complete() }), (function (e) { var n; o = !1, null === (n = r.error) || void 0 === n || n.call(r, e), t.error(e) }), (function () { var e, t; o && (null === (e = r.unsubscribe) || void 0 === e || e.call(r)), null === (t = r.finalize) || void 0 === t || t.call(r) }))) })) : ot } function Vt(e, t) { return ge(this, void 0, void 0, (function* () { try { const n = yield navigator.serviceWorker.ready; if ("push" === t && n.sync && (yield n.sync.register(`dexie-cloud:${e.name}`)), !n.active) throw new Error("Failed to trigger sync - there's no active service worker"); return void n.active.postMessage({ type: "dexie-cloud-sync", dbName: e.name, purpose: t }) } catch (e) { } })) } function qt(e, t) { e.cloud.usingServiceWorker ? Vt(e, t) : e.localSyncEvent.next({ purpose: t }) } const Jt = void 0 !== R ? e => R.from(e, "base64") : e => { const t = atob(e), n = t.length, r = new Uint8Array(n); for (var o = 0; o < n; o++)r[o] = t.charCodeAt(o); return r }, Gt = void 0 !== R ? e => ArrayBuffer.isView(e) ? R.from(e.buffer, e.byteOffset, e.byteLength).toString("base64") : R.from(e).toString("base64") : e => { const t = ArrayBuffer.isView(e) ? e : new Uint8Array(e), n = []; for (let e = 0, r = t.length; e < r; e += 4096) { const r = t.subarray(e, e + 4096); n.push(String.fromCharCode.apply(null, r)) } return btoa(n.join("")) }; class Zt extends Error { constructor({ title: e, message: t, messageCode: n, messageParams: r }) { super(t), this.name = "TokenErrorResponseError", this.title = e, this.messageCode = n, this.messageParams = r } } function Xt(t, n) { return new Promise(((r, o) => { const i = Object.assign(Object.assign({ submitLabel: "Submit", cancelLabel: "Cancel" }, n), { onSubmit: e => { t.next(void 0), r(e) }, onCancel: () => { t.next(void 0), o(new e.AbortError("User cancelled")) } }); t.next(i) })) } function Qt(e, t, ...n) { return Xt(e, { type: "message-alert", title: t, alerts: n, fields: {}, submitLabel: "OK", cancelLabel: null }) } function en(e, t, n) { return ge(this, void 0, void 0, (function* () { let r = n || ""; for (; !r || !/^[\w-+.]+@([\w-]+\.)+[\w-]{2,10}(\sas\s[\w-+.]+@([\w-]+\.)+[\w-]{2,10})?$/.test(r);)r = (yield Xt(e, { type: "email", title: t, alerts: r ? [{ type: "error", messageCode: "INVALID_EMAIL", message: "Please enter a valid email address", messageParams: {} }] : [], fields: { email: { type: "email", placeholder: "you@somedomain.com" } } })).email; return r })) } function tn(e, t, n) { return ge(this, void 0, void 0, (function* () { const r = [{ type: "info", messageCode: "OTP_SENT", message: "A One-Time password has been sent to {email}", messageParams: { email: t } }]; n && r.push(n); const { otp: o } = yield Xt(e, { type: "otp", title: "Enter OTP", alerts: r, fields: { otp: { type: "otp", label: "OTP", placeholder: "Paste OTP here" } } }); return o })) } function nn(e) { var t, n, r; return ge(this, void 0, void 0, (function* () { const o = yield e.getCurrentUser(), { accessToken: i, accessTokenExpiration: s, refreshToken: a, refreshTokenExpiration: u, claims: c } = o; if (!i) return null; if ((null !== (t = null == s ? void 0 : s.getTime()) && void 0 !== t ? t : 1 / 0) > Date.now() && "ok" === ((null === (n = o.license) || void 0 === n ? void 0 : n.status) || "ok")) return o; if (!a) throw new Error("Refresh token missing"); if ((null !== (r = null == u ? void 0 : u.getTime()) && void 0 !== r ? r : 1 / 0) <= Date.now()) throw new Error("Refresh token has expired"); const l = yield on(e.cloud.options.databaseUrl, o); return yield e.table("$logins").update(c.sub, { accessToken: l.accessToken, accessTokenExpiration: l.accessTokenExpiration, claims: l.claims, license: l.license }), l })) } function rn(t, n, r, o, i) { return ge(this, void 0, void 0, (function* () { return n.accessToken && n.accessTokenExpiration.getTime() > Date.now() ? n : n.refreshToken && (!n.refreshTokenExpiration || n.refreshTokenExpiration.getTime() > Date.now()) ? yield on(t, n) : yield function (t, n, r, o) { return ge(this, void 0, void 0, (function* () { if (!crypto.subtle) throw "undefined" != typeof location && "http:" === location.protocol ? new Error("Dexie Cloud Addon needs to use WebCrypto, but your browser has disabled it due to being served from an insecure location. Please serve it from https or http://localhost:<port> (See https://stackoverflow.com/questions/46670556/how-to-enable-crypto-subtle-for-unsecure-origins-in-chrome/46671627#46671627)") : new Error("This browser does not support WebCrypto."); const { privateKey: i, publicKey: s } = yield crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, !1, ["sign", "verify"]); if (!i || !s) throw new Error("Could not generate RSA keypair"); t.nonExportablePrivateKey = i; const a = function (e) { return function (e) { let t = "-----BEGIN PUBLIC KEY-----\n"; for (; e.length > 0;)t += e.substring(0, 64) + "\n", e = e.substring(64); return t += "-----END PUBLIC KEY-----", t }(Gt(e)) }(yield crypto.subtle.exportKey("spki", s)); t.publicKey = s; try { const e = yield n({ public_key: a, hints: o }); if ("error" === e.type) throw new Zt(e); if ("tokens" !== e.type) throw new Error(`Unexpected response type from token endpoint: ${e.type}`); return t.accessToken = e.accessToken, t.accessTokenExpiration = new Date(e.accessTokenExpiration), t.refreshToken = e.refreshToken, e.refreshTokenExpiration && (t.refreshTokenExpiration = new Date(e.refreshTokenExpiration)), t.userId = e.claims.sub, t.email = e.claims.email, t.name = e.claims.name, t.claims = e.claims, t.license = { type: e.userType, status: e.claims.license || "ok" }, t.data = e.data, null != e.evalDaysLeft && (t.license.evalDaysLeft = e.evalDaysLeft), null != e.userValidUntil && (t.license.validUntil = new Date(e.userValidUntil)), e.alerts && e.alerts.length > 0 && (yield Xt(r, { type: "message-alert", title: "Authentication Alert", fields: {}, alerts: e.alerts })), t } catch (t) { if (t instanceof Zt) throw yield Qt(r, t.title, { type: "error", messageCode: t.messageCode, message: t.message, messageParams: {} }), t; let n = "We're having a problem authenticating right now."; throw t instanceof TypeError && (n = void 0 === typeof navigator || navigator.onLine ? e.debug || "undefined" != typeof location && ("localhost" === location.hostname || "127.0.0.1" === location.hostname) ? `Could not connect to server. Please verify that your origin '${location.origin}' is whitelisted using \`npx dexie-cloud whitelist\`` : "Could not connect to server. Please verify the connection." : "You seem to be offline. Please connect to the internet and try again.", yield Qt(r, "Authentication Failed", { type: "error", messageCode: "GENERIC_ERROR", message: n, messageParams: {} }).catch((() => { }))), t } })) }(n, r, o, i) })) } function on(e, t) { return ge(this, void 0, void 0, (function* () { if (!t.refreshToken) throw new Error("Cannot refresh token - refresh token is missing."); if (!t.nonExportablePrivateKey) throw new Error("login.nonExportablePrivateKey is missing - cannot sign refresh token without a private key."); const n = Date.now(), r = "RSASSA-PKCS1-v1_5", o = (new TextEncoder).encode(t.refreshToken + n), i = yield crypto.subtle.sign(r, t.nonExportablePrivateKey, o), s = Gt(i), a = { grant_type: "refresh_token", refresh_token: t.refreshToken, scopes: ["ACCESS_DB"], signature: s, signing_algorithm: r, time_stamp: n }, u = yield fetch(`${e}/token`, { body: JSON.stringify(a), method: "post", headers: { "Content-Type": "application/json" }, mode: "cors" }); if (200 !== u.status) throw new Error(`RefreshToken: Status ${u.status} from ${e}/token`); const c = yield u.json(); if ("error" === c.type) throw new Zt(c); return t.accessToken = c.accessToken, t.accessTokenExpiration = c.accessTokenExpiration ? new Date(c.accessTokenExpiration) : void 0, t.claims = c.claims, t.license = { type: c.userType, status: c.claims.license || "ok" }, null != c.evalDaysLeft && (t.license.evalDaysLeft = c.evalDaysLeft), null != c.userValidUntil && (t.license.validUntil = new Date(c.userValidUntil)), c.data && (t.data = c.data), t })) } const sn = new WeakMap; class an { constructor(e, t) { sn.set(this, e), Object.assign(this, t) } static load(e, t) { return e.table("$logins").get(t).then((n => new an(e, n || { userId: t, claims: { sub: t }, lastLogin: new Date(0) }))) } save() { return ge(this, void 0, void 0, (function* () { sn.get(this).table("$logins").put(this) })) } } const un = { userId: "unauthorized", name: "Unauthorized", claims: { sub: "unauthorized" }, lastLogin: new Date(0) }; try { Object.freeze(un), Object.freeze(un.claims) } catch (e) { } function cn(e, t) { return l(d(e).pipe(v(t))) } function ln(e) { return ge(this, void 0, void 0, (function* () { const t = yield dn(e); if (t) { if (!(yield function (e, t, n) { return ge(this, void 0, void 0, (function* () { const r = [{ type: "warning", messageCode: "LOGOUT_CONFIRMATION", message: "{numUnsyncedChanges} unsynced changes will get lost!\n                Logout anyway?", messageParams: { currentUserId: t, numUnsyncedChanges: n.toString() } }]; return yield Xt(e, { type: "logout-confirmation", title: "Confirm Logout", alerts: r, fields: {}, submitLabel: "Confirm logout", cancelLabel: "Cancel" }).then((() => !0)).catch((() => !1)) })) }(e.cloud.userInteraction, e.cloud.currentUserId, t))) throw new Error("User cancelled logout due to unsynced changes"); yield dn(e, { deleteUnsyncedData: !0 }) } })) } function dn(e, { deleteUnsyncedData: t = !1 } = {}) { return ge(this, void 0, void 0, (function* () { const [n, r] = yield e.dx.transaction("rw", e.dx.tables, (n => ge(this, void 0, void 0, (function* () { const r = n.idbtrans; r.disableChangeTracking = !0, r.disableAccessControl = !0; const o = n.storeNames.filter((e => e.endsWith("_mutations"))), i = (yield Promise.all(o.map((e => n.table(e).count())))).reduce(((e, t) => e + t), 0); if (i > 0 && !t) return [i, !1]; e.$syncState.delete("syncState"); for (const t of e.dx.tables) "$jobs" !== t.name && "$syncState" !== t.name && t.clear(); return [i, !0] })))); return r && (yield cn(e.cloud.currentUser, (e => e.userId === un.userId)), yield e.cloud.sync({ purpose: "pull", wait: !0 })), n })) } class fn extends Error { constructor(e, t) { super(t || `${e.status} ${e.statusText}`), this.httpStatus = e.status } get name() { return "HttpError" } } function hn(e, ...t) { globalThis.console[e](...t) } function pn(e, t) { var n; return ge(this, void 0, void 0, (function* () { const r = yield e.getCurrentUser(), o = r.userId; if (r.isLoggedIn && (!t || !t.email && !t.userId)) { if ("ok" === ((null === (n = r.license) || void 0 === n ? void 0 : n.status) || "ok") && r.accessToken && (!r.accessTokenExpiration || r.accessTokenExpiration.getTime() > Date.now())) return !1; if (r.refreshToken && (!r.refreshTokenExpiration || r.refreshTokenExpiration.getTime() > Date.now())) return yield nn(e), !1 } const i = new an(e, { claims: {}, lastLogin: new Date(0) }); return yield rn(e.cloud.options.databaseUrl, i, e.cloud.options.fetchTokens || function (e) { const { userInteraction: t } = e.cloud; return function ({ public_key: n, hints: r }) { var o; return ge(this, void 0, void 0, (function* () { let i; const s = null === (o = e.cloud.options) || void 0 === o ? void 0 : o.databaseUrl; if (!s) throw new Error("No database URL given."); if ("demo" === (null == r ? void 0 : r.grant_type)) i = { demo_user: yield en(t, "Enter a demo user email", (null == r ? void 0 : r.email) || (null == r ? void 0 : r.userId)), grant_type: "demo", scopes: ["ACCESS_DB"], public_key: n }; else if ((null == r ? void 0 : r.otpId) && r.otp) i = { grant_type: "otp", otp_id: r.otpId, otp: r.otp, scopes: ["ACCESS_DB"], public_key: n }; else { const e = yield en(t, "Enter email address", null == r ? void 0 : r.email); i = /@demo.local$/.test(e) ? { demo_user: e, grant_type: "demo", scopes: ["ACCESS_DB"], public_key: n } : { email: e, grant_type: "otp", scopes: ["ACCESS_DB"] } } const a = yield fetch(`${s}/token`, { body: JSON.stringify(i), method: "post", headers: { "Content-Type": "application/json", mode: "cors" } }); if (200 !== a.status) { const e = yield a.text(); throw yield Qt(t, "Token request failed", { type: "error", messageCode: "GENERIC_ERROR", message: e, messageParams: {} }).catch((() => { })), new fn(a, e) } const u = yield a.json(); if ("tokens" === u.type || "error" === u.type) return u; if ("otp" === i.grant_type && "email" in i) { if ("otp-sent" !== u.type) throw new Error(`Unexpected response from ${s}/token`); const e = yield tn(t, i.email), r = Object.assign(Object.assign({}, i), { otp: e || "", otp_id: u.otp_id, public_key: n }); let o = yield fetch(`${s}/token`, { body: JSON.stringify(r), method: "post", headers: { "Content-Type": "application/json" }, mode: "cors" }); for (; 401 === o.status;) { const e = yield o.text(); r.otp = yield tn(t, i.email, { type: "error", messageCode: "INVALID_OTP", message: e, messageParams: {} }), o = yield fetch(`${s}/token`, { body: JSON.stringify(r), method: "post", headers: { "Content-Type": "application/json" }, mode: "cors" }) } if (200 !== o.status) { const e = yield o.text(); throw new fn(o, e) } return yield o.json() } throw new Error(`Unexpected response from ${s}/token`) })) } }(e), e.cloud.userInteraction, t), o !== un.userId && i.userId !== o && (yield ln(e)), yield function (e, t) { return ge(this, void 0, void 0, (function* () { if (t.userId === e.cloud.currentUserId) return; const n = e.table("$logins"); yield e.transaction("rw", n, (e => ge(this, void 0, void 0, (function* () { const e = yield n.toArray(); yield Promise.all(e.filter((e => e.userId !== t.userId && e.isLoggedIn)).map((e => (e.isLoggedIn = !1, n.put(e))))), t.isLoggedIn = !0, t.lastLogin = new Date; try { yield t.save() } catch (e) { try { "DataCloneError" === e.name && (hn("debug", "Login context property names:", Object.keys(t)), hn("debug", "Login context property names:", Object.keys(t)), hn("debug", "Login context:", t), hn("debug", "Login context JSON:", JSON.stringify(t))) } catch (e) { } throw e } })))), yield cn(e.cloud.currentUser, (e => e.userId === t.userId)) })) }(e, i), qt(e, "pull"), i.userId !== o })) } const yn = {}, vn = "undefined" != typeof self && self.document && "undefined" != typeof navigator && navigator.serviceWorker; vn && vn.ready.then((e => yn.registration = e)), "undefined" != typeof self && "clients" in self && !self.document && addEventListener("message", (e => { var t, n; (null === (n = null === (t = e.data) || void 0 === t ? void 0 : t.type) || void 0 === n ? void 0 : n.startsWith("sw-broadcast-")) && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((t => { var n; return t.id !== (null === (n = e.source) || void 0 === n ? void 0 : n.id) && t.postMessage(e.data) })) })); class mn { constructor(e) { this.name = e } subscribe(e) { if (!vn) return () => { }; const t = t => { var n; (null === (n = t.data) || void 0 === n ? void 0 : n.type) === `sw-broadcast-${this.name}` && e(t.data.message) }; return vn.addEventListener("message", t), () => vn.removeEventListener("message", t) } postMessage(e) { var t; "object" == typeof self.clients ? [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((t => t.postMessage({ type: `sw-broadcast-${this.name}`, message: e }))) : yn.registration && (null === (t = yn.registration.active) || void 0 === t || t.postMessage({ type: `sw-broadcast-${this.name}`, message: e })) } } const bn = globalThis["lbc-events"] || (globalThis["lbc-events"] = new Map); class gn extends h { constructor(e) { const t = "undefined" == typeof BroadcastChannel ? new mn(e) : new BroadcastChannel(e); super((n => { function r(e) { n.next(e.detail) } function o(e) { n.next(e.data) } let i; !function (e, t) { bn.has(e) ? bn.get(e).push(t) : bn.set(e, [t]) }(`lbc-${e}`, r); try { t instanceof mn ? i = t.subscribe((e => n.next(e))) : t.addEventListener("message", o) } catch (e) { } return () => { !function (e, t) { const n = bn.get(e); if (n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } }(`lbc-${e}`, r), t instanceof mn ? i() : t.removeEventListener("message", o) } })), this.name = e, this.bc = t } next(e) { this.bc.postMessage(e), function (e) { const t = bn.get(e.type); t && t.forEach((t => { try { t(e) } catch (e) { } })) }(new CustomEvent(`lbc-${this.name}`, { detail: e })) } } function _n({ realms: e, inviteRealms: t }) { return ge(this, void 0, void 0, (function* () { const n = JSON.stringify([...e.map((e => ({ realmId: e, accepted: !0 }))), ...t.map((e => ({ realmId: e, accepted: !1 })))].sort(((e, t) => e.realmId < t.realmId ? -1 : e.realmId > t.realmId ? 1 : 0))), r = (new TextEncoder).encode(n), o = yield crypto.subtle.digest("SHA-1", r); return Gt(o) })) } function wn(e) { return Object.entries(e.cloud.schema || {}).filter((([, { markedForSync: e }]) => e)).map((([t]) => e.tables.filter((({ name: e }) => e === t))[0])).filter((e => e)) } function Sn(e) { return `$${e}_mutations` } function kn(e) { var t; const n = null === (t = /^\$(.*)_mutations$/.exec(e)) || void 0 === t ? void 0 : t[1]; if (!n) throw new Error(`Given mutationTable ${e} is not correct`); return n } const En = [].concat; function In(e) { return En.apply([], e) } function xn(e, t, { since: n = {}, limit: r = 1 / 0 } = {}) { return ge(this, void 0, void 0, (function* () { const t = In(yield Promise.all(e.map((e => ge(this, void 0, void 0, (function* () { const t = kn(e.name), o = n[t]; let i = o ? e.where("rev").above(o) : e; return r < 1 / 0 && (i = i.limit(r)), (yield i.toArray()).map((e => ({ table: t, mut: e }))) })))))).sort(((e, t) => e.mut.txid === t.mut.txid ? e.mut.opNo - t.mut.opNo : e.mut.ts - t.mut.ts)), o = []; let i = null, s = null; for (const { table: e, mut: n } of t) i && i.table === e && s === n.txid ? i.muts.push(n) : (i = { table: e, muts: [n] }, s = n.txid, o.push(i)); return o })) } function An(e) { const t = new Uint8Array(e); if ("undefined" != typeof crypto) crypto.getRandomValues(t); else for (let n = 0; n < e; n++)t[n] = Math.floor(256 * Math.random()); if (void 0 !== R && R.from) return R.from(t).toString("base64"); if ("undefined" != typeof btoa) return btoa(String.fromCharCode.apply(null, t)); throw new Error("No btoa or Buffer available") } const { toString: Tn } = {}, On = { replace: function (e) { const t = Object.keys(e); let n = null; for (let e = 0, r = t.length; e < r; ++e)"$" === t[e][0] && (n = n || [], n.push(t[e])); if (!n) return e; const r = { ...e }; for (const e of n) delete r[e]; for (const t of n) r["$" + t] = e[t]; return r } }; function Pn(...e) { const t = e.reduce(((e, t) => ({ ...e, ...t })), e.reduce(((e, t) => ({ ...t, ...e })), {})), n = new WeakMap; return { stringify(e, r, o) { const i = JSON.stringify(e, (function (e) { const o = this[e], i = function (e) { const r = typeof e; switch (typeof e) { case "object": case "function": { if (null === e) return null; const r = Object.getPrototypeOf(e); if (!r) return On; let i = n.get(r); if (void 0 !== i) return i; const s = (o = e, Tn.call(o).slice(8, -1)), a = Object.entries(t).find((([t, n]) => { var r, o; return null !== (o = null === (r = null == n ? void 0 : n.test) || void 0 === r ? void 0 : r.call(n, e, s)) && void 0 !== o ? o : t === s })); return i = null == a ? void 0 : a[1], i || (i = Array.isArray(e) ? null : "function" == typeof e ? t.function || null : On), n.set(r, i), i } default: return t[r] }var o }(o); return i ? i.replace(o, r, t) : o }), o); return i }, parse(e, n) { const r = []; return JSON.parse(e, (function (e, o) { const i = null == o ? void 0 : o.$t; if (i) { const e = t[i]; o = e ? e.revive(o, n, t) : o } let s = r[r.length - 1]; if (s && s[0] === o) { o = { ...o }; for (const e of s[1]) delete o[e]; for (const [e, t] of Object.entries(s[2])) o[e] = t; r.pop() } if (void 0 === o || "$" === e[0] && "$t" !== e) { let t, n; s = r[r.length - 1], s && s[0] === this ? (t = s[1], n = s[2]) : r.push([this, t = [], n = {}]), "$" === e[0] && "$t" !== e ? (t.push(e), n[e.substr(1)] = o) : n[e] = void 0 } return o })) } } } const Cn = { Blob: { test: (e, t) => "Blob" === t, replace: (e, t) => { const n = t.length; return t.push(e), { $t: "Blob", mimeType: e.type, i: n } }, revive: ({ i: e, mimeType: t }, n) => new Blob([n[e]], { type: t }) } }; var Un = { number: { replace: e => { switch (!0) { case isNaN(e): return { $t: "number", v: "NaN" }; case e === 1 / 0: return { $t: "number", v: "Infinity" }; case e === -1 / 0: return { $t: "number", v: "-Infinity" }; default: return e } }, revive: ({ v: e }) => Number(e) } }; const Rn = { bigint: { replace: e => ({ $t: "bigint", v: "" + e }), revive: e => BigInt(e.v) } }; var jn = { Date: { replace: e => ({ $t: "Date", v: isNaN(e.getTime()) ? "NaN" : e.toISOString() }), revive: ({ v: e }) => new Date("NaN" === e ? NaN : Date.parse(e)) } }, Ln = { Set: { replace: e => ({ $t: "Set", v: Array.from(e.entries()) }), revive: ({ v: e }) => new Set(e) } }, Dn = { Map: { replace: e => ({ $t: "Map", v: Array.from(e.entries()) }), revive: ({ v: e }) => new Map(e) } }; const $n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : void 0 !== g ? g : void 0; var Nn = ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "DataView", "BigInt64Array", "BigUint64Array"].reduce(((e, t) => ({ ...e, [t]: { replace: (e, n, r) => ({ $t: t, v: r.ArrayBuffer.replace(0 === e.byteOffset && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength), n, r).v }), revive: ({ v: e }, n, r) => { const o = $n[t]; return o && new o(r.ArrayBuffer.revive({ v: e }, n, r)) } } })), {}); function Bn(e) { return function (e) { for (var t = "", n = 0, r = e.length; n < r; n++)t += Wn[e[n]]; return t }(Gt(e)) } const Mn = { "-": "=", 0: "A", 1: "B", 2: "C", 3: "D", 4: "E", 5: "F", 6: "G", 7: "H", 8: "I", 9: "J", A: "K", B: "L", C: "M", D: "N", E: "O", F: "P", G: "Q", H: "R", I: "S", J: "T", K: "U", L: "V", M: "W", N: "X", O: "Y", P: "Z", Q: "a", R: "b", S: "c", T: "d", U: "e", V: "f", W: "g", X: "h", Y: "i", Z: "j", _: "k", a: "l", b: "m", c: "n", d: "o", e: "p", f: "q", g: "r", h: "s", i: "t", j: "u", k: "v", l: "w", m: "x", n: "y", o: "z", p: "0", q: "1", r: "2", s: "3", t: "4", u: "5", v: "6", w: "7", x: "8", y: "9", z: "+", "|": "/" }, Wn = {}; for (const e of Object.keys(Mn)) Wn[Mn[e]] = e; var Fn = { ArrayBuffer: { replace: e => ({ $t: "ArrayBuffer", v: Bn(e) }), revive: ({ v: e }) => { const t = function (e) { return Jt(function (e) { if ("string" != typeof e) throw new Error("invalid decoder input: " + e); for (var t = "", n = 0, r = e.length; n < r; n++)t += Mn[e[n]]; return t }(e)) }(e); return t.buffer.byteLength === t.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength) } } }; class Yn { constructor(e, t) { this.buf = e, this.type = t } } function Kn(e) { const t = new XMLHttpRequest; if (t.overrideMimeType("text/plain; charset=x-user-defined"), t.open("GET", URL.createObjectURL(e), !1), t.send(), 200 !== t.status && 0 !== t.status) throw new Error("Bad Blob access: " + t.status); return t.responseText } function zn(e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; ++n)t[n] = e.charCodeAt(n); return t.buffer } var Hn = { Blob: { test: (e, t) => "Blob" === t || e instanceof Yn, replace: e => ({ $t: "Blob", v: Gt(e instanceof Yn ? e.buf : zn(Kn(e))), type: e.type }), revive: ({ type: e, v: t }) => { const n = Jt(t); return void 0 !== typeof Blob ? new Blob([n]) : new Yn(n.buffer, e) } } }; const Vn = { ...Un, ...Rn, ...jn, ...Ln, ...Dn, ...Nn, ...Fn, ...Hn }; function qn(e) { return new Promise(((t, n) => { const r = new FileReader; r.onabort = e => n(new Error("file read aborted")), r.onerror = e => n(e.target.error), r.onload = e => t(e.target.result), r.readAsArrayBuffer(e) })) } const Jn = "function" == typeof BigInt && "bigint" == typeof BigInt(0); class Gn { toString() { return this.v } constructor(e) { this.v = e } } const Zn = Jn ? {} : { bigint: { test: e => e instanceof Gn, replace: e => Object.assign({ $t: "bigint" }, e), revive: ({ v: e }) => new Gn(e) } }, Xn = Object.assign(Object.assign(Object.assign({}, { undefined: { replace: () => ({ $t: "undefined" }), revive: () => { } } }), Zn), { PropModification: { test: e => e instanceof t, replace: e => Object.assign({ $t: "PropModification" }, e["@@propmod"]), revive: e => { var n = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var o = 0; for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]) } return n }(e, ["$t"]); return new t(n) } } }), Qn = Pn(Vn, Xn), er = function () { const e = Pn(Vn, Cn, ...[Xn]); return { toBinary(e) { const [t, n] = this.stringify(e), r = new ArrayBuffer(4); return new DataView(r).setUint32(0, t.size), new Blob([r, t, n]) }, stringify(t) { const n = [], r = e.stringify(t, n), o = new Blob(n.map((e => { const t = new ArrayBuffer(4); return new DataView(t).setUint32(0, "byteLength" in e ? e.byteLength : e.size), new Blob([t, e]) }))); return [o, r] }, async parse(t, n) { let r = 0; const o = [], i = await qn(n), s = new DataView(i); for (; r < i.byteLength;) { const e = s.getUint32(r); r += 4; const t = i.slice(r, r + e); r += e, o.push(t) } return e.parse(t, o) }, async fromBinary(e) { const t = new DataView(await qn(e.slice(0, 4))).getUint32(0), n = e.slice(4, t + 4), r = await function (e) { return new Promise(((t, n) => { const r = new FileReader; r.onabort = e => n(new Error("file read aborted")), r.onerror = e => n(e.target.error), r.onload = e => t(e.target.result), r.readAsText(e) })) }(e.slice(t + 4)); return await this.parse(r, n) } } }(); function tr(t, n, r) { const o = []; for (let i of r) { const { table: r, muts: s } = i, a = t.tables.find((e => e.name === r)); if (!a) throw new Error(`Internal error: table ${r} not found in DBCore schema`); const { primaryKey: u } = a; let c = i; s.forEach(((t, r) => { const o = !u.outbound && ("upsert" === t.type || "insert" === t.type); t.keys.forEach(((t, s) => { if (Array.isArray(t)) { c === i && (c = nr(i, o)); const e = c.muts[r], n = JSON.stringify(t); e.keys[s] = n } else if ("#" === t[0]) { c === i && (c = nr(i, o)); const a = c.muts[r]; if (!n.isLoggedIn) throw new Error("Internal error: Cannot sync private IDs before authenticated"); const l = `${t}:${n.userId}`; a.keys[s] = l, o && e.setByKeyPath(a.values[s], u.keyPath, l) } })) })), o.push(c) } return o } function nr(e, t) { return Object.assign(Object.assign({}, e), { muts: t ? e.muts.map((e => "insert" !== e.type && "upsert" !== e.type || !e.values ? Object.assign(Object.assign({}, e), { keys: e.keys.slice() }) : Object.assign(Object.assign({}, e), { keys: e.keys.slice(), values: e.values.slice() }))) : e.muts.map((e => Object.assign(Object.assign({}, e), { keys: e.keys.slice() }))) }) } let rr = new WeakMap; function or(e) { var t, n; return ge(this, void 0, void 0, (function* () { const r = (null !== (n = null === (t = rr.get(e)) || void 0 === t ? void 0 : t.getTime()) && void 0 !== n ? n : 0) - Date.now(); r > 0 && (yield new Promise((e => setTimeout(e, r)))) })) } function ir(t) { if (null == t ? void 0 : t.cancelled) throw new e.AbortError("Operation was cancelled") } let sr = !1; function ar(e, t, n, r) { return ge(this, void 0, void 0, (function* () { yield e.$baseRevs.bulkPut(Object.keys(t).filter((e => t[e].markedForSync)).map((e => ({ tableName: e, clientRev: (n[e] || 0) + 1, serverRev: r })))) })) } function ur(e, t = {}) { for (const { table: n, muts: r } of e) { const e = r.length > 0 ? r[r.length - 1].rev : null; t[n] = e || t[n] || 0 } return t } function cr(t, n, o) { return ge(this, void 0, void 0, (function* () { const i = yield t.bulkGet(n), s = [], a = []; n.forEach(((n, u) => { const c = i[u]; if (c) { for (const [i, s] of Object.entries(o[u])) if (i === t.schema.primKey.keyPath) { if (0 !== r(s, n)) throw new Error("Cannot change primary key") } else e.setByKeyPath(c, i, s); s.push(n), a.push(c) } })), yield null == t.schema.primKey.keyPath ? t.bulkPut(a, s) : t.bulkPut(a) })) } function lr(t, n) { return ge(this, void 0, void 0, (function* () { for (const { table: r, muts: o } of t) { const t = n.table(r); if (!t) continue; const { primaryKey: i } = t.core.schema, s = e => { switch (e[0]) { case "[": if (e.endsWith("]")) try { return JSON.parse(e) } catch (e) { } return e; case "#": return e.endsWith(":" + n.cloud.currentUserId) ? e.substr(0, e.length - n.cloud.currentUserId.length - 1) : e; default: return e } }; for (const n of o) { const r = n.keys.map(s); switch (n.type) { case "insert": i.outbound ? yield t.bulkAdd(n.values, r) : (r.forEach(((t, r) => { e.setByKeyPath(n.values[r], i.keyPath, t) })), yield t.bulkAdd(n.values)); break; case "upsert": i.outbound ? yield t.bulkPut(n.values, r) : (r.forEach(((t, r) => { e.setByKeyPath(n.values[r], i.keyPath, t) })), yield t.bulkPut(n.values)); break; case "modify": 1 === r.length ? yield t.update(r[0], n.changeSpec) : yield t.where(":id").anyOf(r).modify(n.changeSpec); break; case "update": yield cr(t, r, n.changeSpecs); break; case "delete": yield t.bulkDelete(r) } } } })) } "undefined" != typeof self && "undefined" != typeof navigator && (sr = navigator.onLine, self.addEventListener("online", (() => sr = !0)), self.addEventListener("offline", (() => sr = !1))); function dr(e, t, n, r) { return fr.apply(this, arguments).then((t => ((null == r ? void 0 : r.justCheckIfNeeded) || e.syncStateChangedEvent.next({ phase: "in-sync" }), t))).catch((o => ge(this, void 0, void 0, (function* () { return (null == r ? void 0 : r.justCheckIfNeeded) ? Promise.reject(o) : sr && (null == r ? void 0 : r.retryImmediatelyOnFetchError) && "TypeError" === (null == o ? void 0 : o.name) && /fetch/.test(null == o ? void 0 : o.message) ? (e.syncStateChangedEvent.next({ phase: "error", error: o }), yield new Promise((e => setTimeout(e, 500))), yield dr(e, t, n, Object.assign(Object.assign({}, r), { retryImmediatelyOnFetchError: !1 }))) : (yield e.$syncState.update("syncState", { timestamp: new Date, error: "" + o }), e.syncStateChangedEvent.next({ phase: sr ? "error" : "offline", error: new Error("" + (null == o ? void 0 : o.message) || o) }), Promise.reject(o)) })))) } function fr(e, t, n, { isInitialSync: r, cancelToken: o, justCheckIfNeeded: i, purpose: s } = { isInitialSync: !1 }) { var a; return ge(this, void 0, void 0, (function* () { if (!(null === (a = e.cloud.options) || void 0 === a ? void 0 : a.databaseUrl)) throw new Error("Internal error: sync must not be called when no databaseUrl is configured"); const { databaseUrl: u } = t, c = yield e.getCurrentUser(), l = c.isLoggedIn ? wn(e) : [], d = l.map((t => e.table(Sn(t.name)))), f = yield e.getPersistedSyncState(), h = !r && c.isLoggedIn, p = h ? function (e, t) { const n = (null == t ? void 0 : t.syncedTables) || []; return wn(e).filter((e => !n.includes(e.name))) }(e, f) : []; ir(o); const y = p.length > 0; if (y) { if (i) return !0; yield e.transaction("rw", p, (e => ge(this, void 0, void 0, (function* () { e.idbtrans.disableChangeTracking = !0, e.idbtrans.disableAccessControl = !0, yield function (e, t, n) { return ge(this, void 0, void 0, (function* () { const r = new Set(n || []); for (const n of e) "members" === n.name ? yield n.toCollection().modify((e => { r.has(e.realmId) || e.userId && e.userId !== un.userId || (e.userId = t.userId) })) : "roles" === n.name || ("realms" === n.name ? yield n.toCollection().modify((e => { r.has(e.realmId) || void 0 !== e.owner && e.owner !== un.userId || (e.owner = t.userId) })) : yield n.toCollection().modify((e => { e.realmId && r.has(e.realmId) || (e.owner && e.owner !== un.userId || (e.owner = t.userId), e.realmId && e.realmId !== un.userId || (e.realmId = t.userId)) }))) })) }(p, c, null == f ? void 0 : f.realms) })))), ir(o) } const [v, m, b] = yield e.transaction("r", e.tables, (() => ge(this, void 0, void 0, (function* () { const t = yield e.getPersistedSyncState(), r = yield e.$baseRevs.toArray(); let i = yield xn(d); if (ir(o), y) { const e = [...(null == f ? void 0 : f.realms) || [], ...(null == f ? void 0 : f.inviteRealms) || []], s = yield function (e, t, n, r) { return ge(this, void 0, void 0, (function* () { const o = `upload-${An(8)}`; if (t.isLoggedIn && e.length > 0) { const i = new Set(r || []); return (yield Promise.all(e.map((e => ge(this, void 0, void 0, (function* () { const { extractKey: r } = e.core.schema.primaryKey; if (!r) return { table: e.name, muts: [] }; const s = n[e.name], a = (null == s ? void 0 : s.generatedGlobalId) ? e.filter((e => { return r(e), !i.has(e.realmId || "") && (t = r(e), !(n = null == s ? void 0 : s.idPrefix) || "string" == typeof t && t.startsWith(n)); var t, n })) : e.filter((e => { const t = r(e); return !i.has(e.realmId || "") && Pe(t) })), u = yield a.toArray(); if (u.length > 0) { const n = { type: "upsert", values: u, keys: u.map(r), userId: t.userId, txid: o }; return { table: e.name, muts: [n] } } return { table: e.name, muts: [] } })))))).filter((e => e.muts.length > 0)) } return [] })) }(p, c, n, e); return ir(o), i = i.concat(s), [i, t, r] } return [i, t, r] })))), g = v.some((e => e.muts.some((e => e.keys.length > 0)))); if (i) return g; if ("push" === s && !g) return !1; const _ = ur(v, null == m ? void 0 : m.latestRevisions), w = (null == m ? void 0 : m.clientIdentity) || Te(16); ir(o); const S = yield function (e, t, n, r, o, i, s, a) { return ge(this, void 0, void 0, (function* () { const u = { Accept: "application/json, application/x-bison, application/x-bison-stream", "Content-Type": "application/tson" }, c = yield nn(r), l = null == c ? void 0 : c.accessToken; l && (u.Authorization = `Bearer ${l}`); const d = { v: 2, dbID: null == t ? void 0 : t.remoteDbId, clientIdentity: s, schema: i || {}, lastPull: t ? { serverRevision: t.serverRevision, realms: t.realms, inviteRealms: t.inviteRealms } : void 0, baseRevs: n, changes: tr(r.dx.core.schema, a, e) }; r.syncStateChangedEvent.next({ phase: "pushing" }); const f = yield fetch(`${o}/sync`, { method: "post", headers: u, credentials: "include", body: Qn.stringify(d) }); if (r.syncStateChangedEvent.next({ phase: "pulling" }), function (e, t) { const n = t.headers.get("Ratelimit-Limit"), r = t.headers.get("Ratelimit-Remaining"), o = t.headers.get("Ratelimit-Reset"); if (n && r && o) { const t = Number(n), i = Math.max(0, Number(r)), s = Number(o); if (i < t / 2) { const t = Math.ceil(s / (i + 1)); rr.set(e, new Date(Date.now() + 1e3 * t)) } else rr.delete(e) } }(r, f), !f.ok) throw new fn(f); if ("application/x-bison" === f.headers.get("content-type")) return er.fromBinary(yield f.blob()); { const e = yield f.text(); return Qn.parse(e) } })) }(v, m, b, e, u, n, w, c), k = yield e.transaction("rw", e.tables, (t => ge(this, void 0, void 0, (function* () { t.idbtrans.disableChangeTracking = !0, t.idbtrans.disableAccessControl = !0; for (const e of Object.keys(n)) S.schema[e] && (n[e] = S.schema[e]); yield e.$syncState.put(n, "schema"); const r = yield xn(d, 0, { since: _ }); for (const t of d) { const n = kn(t.name); if (r.some((e => e.table === n && e.muts.length > 0))) { if (_[n]) { const r = _[n] || 0; yield Promise.all([t.where("rev").belowOrEqual(r).delete(), e.$baseRevs.where(":id").between([n, -1 / 0], [n, r + 1], !0, !0).reverse().offset(1).delete()]) } } else yield Promise.all([t.clear(), e.$baseRevs.where({ tableName: n }).delete()]) } ur(r, _), yield ar(e, n, _, S.serverRevision); const o = yield e.getPersistedSyncState(); yield function (e, t, n) { return ge(this, void 0, void 0, (function* () { const r = new Set, o = new Set, i = n ? n.realms : [], s = n ? n.inviteRealms : [], a = new Set(t.realms), u = new Set(t.realms.concat(t.inviteRealms)); for (const e of i) a.has(e) || (o.add(e), u.has(e) || r.add(e)); for (const e of s.concat(i)) u.has(e) || r.add(e); if (r.size > 0 || o.size > 0) { const t = wn(e); for (const e of t) { let t = ["realms", "members", "roles"].includes(e.name) ? r : o; 0 !== t.size && (e.schema.indexes.some((e => "realmId" === e.keyPath || Array.isArray(e.keyPath) && "realmId" === e.keyPath[0])) ? yield e.where("realmId").anyOf([...t]).delete() : yield e.filter((e => !!(null == e ? void 0 : e.realmId) && t.has(e.realmId))).delete()) } } })) }(e, S, o); const i = o || { syncedTables: [], latestRevisions: {}, realms: [], inviteRealms: [], clientIdentity: w }; h && (i.syncedTables = l.map((e => e.name)).concat(p.map((e => e.name)))), i.latestRevisions = _, i.remoteDbId = S.dbId, i.initiallySynced = !0, i.realms = S.realms, i.inviteRealms = S.inviteRealms, i.serverRevision = S.serverRevision, i.timestamp = new Date, delete i.error; const s = hr(S.changes, r); return yield lr(s, e), e.$syncState.put(i, "syncState"), 0 === r.length })))); return k ? (e.syncCompleteEvent.next(), !1) : (yield or(e), yield fr(e, t, n, { isInitialSync: r, cancelToken: o })) })) } function hr(e, t) { const n = {}; Re(n, e); const r = {}; return Re(r, t), function (e, t) { var n, r, o; for (const [i, s] of Object.entries(t)) for (const [t, a] of Object.entries(s)) switch (a.type) { case "ups": { const r = null === (n = e[i]) || void 0 === n ? void 0 : n[t]; if (r) switch (r.type) { case "ups": case "upd": delete e[i][t] } } break; case "del": null === (r = e[i]) || void 0 === r || delete r[t]; break; case "upd": { const n = null === (o = e[i]) || void 0 === o ? void 0 : o[t]; if (n) switch (n.type) { case "ups": for (const [e, t] of Object.entries(a.mod)) Ae(n.val, e, t); break; case "del": break; case "upd": for (const e of Object.keys(a.mod)) delete n.mod[e] }break } } }(n, r), function (e, t = "") { t || (t = Te(16)); const n = {}; for (const [t, r] of Object.entries(e)) for (const [e, o] of Object.entries(r)) { const r = n[t] || (n[t] = {}); (r[o.type] || (r[o.type] = [])).push(Object.assign({ key: e }, o)) } const r = []; for (const [e, o] of Object.entries(n)) { const n = { table: e, muts: [] }; for (const [e, r] of Object.entries(o)) switch (e) { case "ups": { const e = { type: "upsert", keys: r.map((e => e.key)), values: r.map((e => e.val)), txid: t }; n.muts.push(e); break } case "upd": { const e = { type: "update", keys: r.map((e => e.key)), changeSpecs: r.map((e => e.mod)), txid: t }; n.muts.push(e); break } case "del": { const e = { type: "delete", keys: r.map((e => e.key)), txid: t }; n.muts.push(e); break } }r.push(n) } return r }(n) } function pr(t) { const n = [], r = new o(!0), i = new o(null); let s = !1, a = new Array(10).fill(0); return i.subscribe((() => ge(this, void 0, void 0, (function* () { if (!s && n.length > 0) { s = !0, a.shift(), a.push(Date.now()), r.next(!1); try { yield function () { var r, o, i, s, a, u; return ge(this, void 0, void 0, (function* () { for (; n.length > 0;) { const c = n.shift(); try { yield l(t.cloud.syncState.pipe(Ft((({ phase: e }) => "in-sync" === e || "error" === e)))); const n = t.cloud.persistedSyncState.value; if (!c) continue; switch (c.type) { case "token-expired": const l = t.cloud.currentUser.value, d = yield on(t.cloud.options.databaseUrl, l); yield t.table("$logins").update(l.userId, { accessToken: d.accessToken, accessTokenExpiration: d.accessTokenExpiration, claims: d.claims, license: d.license, data: d.data }); break; case "realm-added": (null === (r = null == n ? void 0 : n.realms) || void 0 === r ? void 0 : r.includes(c.realm)) || (null === (o = null == n ? void 0 : n.inviteRealms) || void 0 === o ? void 0 : o.includes(c.realm)) || (yield t.cloud.sync({ purpose: "pull", wait: !0 })); break; case "realm-accepted": (null === (i = null == n ? void 0 : n.realms) || void 0 === i ? void 0 : i.includes(c.realm)) || (yield t.cloud.sync({ purpose: "pull", wait: !0 })); break; case "realm-removed": ((null === (s = null == n ? void 0 : n.realms) || void 0 === s ? void 0 : s.includes(c.realm)) || (null === (a = null == n ? void 0 : n.inviteRealms) || void 0 === a ? void 0 : a.includes(c.realm))) && (yield t.cloud.sync({ purpose: "pull", wait: !0 })); break; case "realms-changed": yield t.cloud.sync({ purpose: "pull", wait: !0 }); break; case "changes": if ("error" === (null === (u = t.cloud.syncState.value) || void 0 === u ? void 0 : u.phase)) { qt(t, "pull"); break } yield t.transaction("rw", t.dx.tables, (n => ge(this, void 0, void 0, (function* () { n.idbtrans.disableChangeTracking = !0, n.idbtrans.disableAccessControl = !0; const [r, o, i] = yield Promise.all([t.getSchema(), t.getPersistedSyncState(), t.getCurrentUser()]); if (!o || !r || !i) return; if (c.baseRev !== o.serverRevision) return void ("string" != typeof c.baseRev || "bigint" != typeof o.serverRevision && "object" != typeof o.serverRevision || qt(t, "pull")); if ((yield e.waitFor(_n(o))) !== c.realmSetHash) return void qt(t, "pull"); let s = []; if (i.isLoggedIn) { const e = wn(t).map((e => t.table(Sn(e.name)))); s = yield xn(e) } if (c.changes.length > 0) { const e = hr(c.changes, s); yield lr(e, t) } o.latestRevisions = ur(s, o.latestRevisions), o.serverRevision = c.newRev, yield ar(t, r, o.latestRevisions, c.newRev), yield t.$syncState.put(o, "syncState") })))) } } catch (e) { } } })) }() } finally { a[a.length - 1] - a[0] < 1e4 && (yield new Promise((e => setTimeout(e, 1e3)))), s = !1, r.next(!0) } } })))), { enqueue: function (e) { n.push(e), i.next(null) }, readyToServe: r } } const yr = new WeakMap, vr = { members: "@id, [userId+realmId], [email+realmId], realmId", roles: "[realmId+name]", realms: "@realmId", $jobs: "", $syncState: "", $baseRevs: "[tableName+clientRev]", $logins: "claims.sub, lastLogin" }; let mr = 0; function br(e) { "vip" in e && (e = e.vip); let t = yr.get(e.cloud); if (!t) { const n = new u; let r = new gn(`syncstatechanged-${e.name}`), o = new gn(`synccomplete-${e.name}`); n.id = ++mr; let i = !1; t = { get name() { return e.name }, close: () => e.close(), transaction: e.transaction.bind(e), table: e.table.bind(e), get tables() { return e.tables }, cloud: e.cloud, get $jobs() { return e.table("$jobs") }, get $syncState() { return e.table("$syncState") }, get $baseRevs() { return e.table("$baseRevs") }, get $logins() { return e.table("$logins") }, get realms() { return e.realms }, get members() { return e.members }, get roles() { return e.roles }, get initiallySynced() { return i }, localSyncEvent: n, get syncStateChangedEvent() { return r }, get syncCompleteEvent() { return o }, dx: e }; const s = { getCurrentUser: () => t.$logins.toArray().then((e => e.find((e => e.isLoggedIn)) || un)), getPersistedSyncState: () => t.$syncState.get("syncState"), getSchema: () => t.$syncState.get("schema").then((e => { if (e) for (const r of t.tables) r.schema.primKey && r.schema.primKey.keyPath && e[r.name] && (e[r.name].primaryKey = "string" == typeof (n = r.schema.primKey.keyPath) ? n : n ? "[" + [].join.call(n, "+") + "]" : ""); var n; return e })), getOptions: () => t.$syncState.get("options"), setInitiallySynced(e) { i = e }, reconfigure() { r = new gn(`syncstatechanged-${e.name}`), o = new gn(`synccomplete-${e.name}`) } }; Object.assign(t, s), t.messageConsumer = pr(t), yr.set(e.cloud, t) } return t } const gr = "undefined" != typeof InstallTrigger, _r = "undefined" != typeof navigator && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\/|Edge\//.test(navigator.userAgent), wr = _r ? [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] : NaN, Sr = _r && wr <= 605 || gr, kr = "undefined" != typeof self && "clients" in self && !self.document; function Er() { throw new e.SchemaError("Version increment needed to allow dexie-cloud change tracking") } const { toString: Ir } = {}; function xr(e) { return Ir.call(e).slice(8, -1) } function Ar(e, t) { var n; return "delete" === t.type ? t.keys : (null === (n = t.keys) || void 0 === n ? void 0 : n.slice()) || t.values.map(e.extractKey) } const Tr = /b|c|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|x|y|z/i; let Or = 0; function Pr(e, t) { const n = new Uint8Array(18), r = new Uint8Array(n.buffer, 0, 6), o = Date.now(); Or >= o ? ++Or : Or = o, r[0] = Or / 1099511627776, r[1] = Or / 4294967296, r[2] = Or / 16777216, r[3] = Or / 65536, r[4] = Or / 256, r[5] = Or; const i = new Uint8Array(n.buffer, 6); return crypto.getRandomValues(i), e + Bn(new Uint8Array(n.buffer)) + (t || "") } let Cr = 0; function Ur(e, t) { return function (n) { const { readers: r, writers: o } = n.trans[t] || (n.trans[t] = { writers: [], readers: [] }), i = o.length, s = (i > 0 ? o[i - 1].then((() => e(n)), (() => e(n))) : e(n)).finally((() => { r.splice(r.indexOf(s)) })); return r.push(s), s } } function Rr(e, t) { return function (n) { const { readers: r, writers: o } = n.trans[t] || (n.trans[t] = { writers: [], readers: [] }); let i = (o.length > 0 ? o[o.length - 1].then((() => e(n)), (() => e(n))) : r.length > 0 ? (s = r, new Promise((e => { 0 === s.length && e([]); let t = s.length; const n = new Array(t); s.forEach(((r, o) => Promise.resolve(r).then((e => n[o] = { status: "fulfilled", value: e }), (e => n[o] = { status: "rejected", reason: e })).then((() => --t || e(n))))) }))).then((() => e(n))) : e(n)).finally((() => { o.shift() })); var s; return o.push(i), i } } const jr = new o(new Set); function Lr(e) { var t, n, r, o; return (null === (t = e.cloud.options) || void 0 === t ? void 0 : t.disableEagerSync) || "ok" !== (null === (r = null === (n = e.cloud.currentUser.value) || void 0 === n ? void 0 : n.license) || void 0 === r ? void 0 : r.status) || !(null === (o = e.cloud.options) || void 0 === o ? void 0 : o.databaseUrl) } const Dr = new o(!0), $r = new o(!0); Dr.pipe(zt((e => e ? s(!0) : s(!1).pipe(Bt(2e4)))), Mt()).subscribe($r); const Nr = "undefined" != typeof document ? i(document, "visibilitychange") : s({}), Br = Nr.pipe(Ft((() => "hidden" === document.visibilityState))), Mr = Nr.pipe(Ft((() => "visible" === document.visibilityState))), Wr = "undefined" != typeof window ? a(Mr, i(window, "mousedown"), i(window, "mousemove"), i(window, "keydown"), i(window, "wheel"), i(window, "touchmove")) : s({}); "undefined" != typeof document && a(s(!0), Br, Wr).pipe(Ut((() => "visible" === document.visibilityState)), Ht((e => { Dr.value !== e && Dr.next(e) })), zt((e => e ? s(0).pipe(Bt(16e4), Ht((() => Dr.next(!1)))) : s(0)))).subscribe((() => { })); class Fr extends Error { constructor() { super(...arguments), this.name = "TokenExpiredError" } } class Yr extends h { constructor(e, t, n, r, o, i, s, a) { super((u => new zr(e, t, n, r, s, a, u, o, i))) } } let Kr = 0; class zr extends p { constructor(e, t, n, r, o, i, s, a, u) { super((() => this.teardown())), this.id = ++Kr, this.reconnecting = !1, this.databaseUrl = e, this.rev = t, this.realmSetHash = n, this.clientIdentity = r, this.token = o, this.tokenExpiration = i, this.subscriber = s, this.lastUserActivity = new Date, this.messageProducer = a, this.messageProducerSubscription = null, this.webSocketStatus = u, this.connect() } teardown() { this.disconnect() } disconnect() { if (this.webSocketStatus.next("disconnected"), this.pinger && (clearInterval(this.pinger), this.pinger = null), this.ws) try { this.ws.close() } catch (e) { } this.ws = null, this.messageProducerSubscription && (this.messageProducerSubscription.unsubscribe(), this.messageProducerSubscription = null) } reconnect() { if (!this.reconnecting) { this.reconnecting = !0; try { this.disconnect() } catch (e) { } this.connect().catch((() => { })).then((() => this.reconnecting = !1)) } } connect() { return ge(this, void 0, void 0, (function* () { if (this.lastServerActivity = new Date, this.pauseUntil && this.pauseUntil > new Date) return; if (this.ws) throw new Error("Called connect() when a connection is already open"); if (!this.databaseUrl) throw new Error("Cannot connect without a database URL"); if (this.closed) return; if (this.tokenExpiration && this.tokenExpiration < new Date) return void this.subscriber.error(new Fr); this.webSocketStatus.next("connecting"), this.pinger = setInterval((() => ge(this, void 0, void 0, (function* () { if (this.closed) this.teardown(); else if (this.ws) try { this.ws.send(JSON.stringify({ type: "ping" })), setTimeout((() => { this.pinger && (this.closed ? this.teardown() : this.lastServerActivity < new Date(Date.now() - 2e4) && this.reconnect()) }), 2e4) } catch (e) { this.reconnect() } else this.reconnect() }))), 3e4); const e = new URL(this.databaseUrl); e.protocol = "http:" === e.protocol ? "ws" : "wss"; const t = new URLSearchParams; if (this.subscriber.closed) return; t.set("v", "2"), t.set("rev", this.rev), t.set("realmsHash", this.realmSetHash), t.set("clientId", this.clientIdentity), this.token && t.set("token", this.token); const n = this.ws = new WebSocket(`${e}/changes?${t}`); n.onclose = e => { this.pinger && this.reconnect() }, n.onmessage = e => { if (this.pinger) { this.lastServerActivity = new Date; try { const t = Qn.parse(e.data); if ("error" === t.type) throw new Error(`Error message from dexie-cloud: ${t.error}`); "rev" === t.type && (this.rev = t.rev), "pong" !== t.type && this.subscriber.next(t) } catch (e) { this.subscriber.error(e) } } }; try { let e = !1; yield new Promise(((t, r) => { n.onopen = n => { e = !0, t(null) }, n.onerror = t => { if (e) this.reconnect(); else { const e = t.error || new Error("WebSocket Error"); this.subscriber.error(e), this.webSocketStatus.next("error"), r(e) } } })), this.messageProducerSubscription = this.messageProducer.subscribe((e => { var t; this.closed || ("ready" === e.type && "connected" !== this.webSocketStatus.value && this.webSocketStatus.next("connected"), null === (t = this.ws) || void 0 === t || t.send(Qn.stringify(e))) })) } catch (e) { this.pauseUntil = new Date(Date.now() + 6e4) } })) } } class Hr extends Error { constructor(e) { super("expired" === e ? "License expired" : "deactivated" === e ? "User deactivated" : "Invalid license"), this.name = "InvalidLicenseError", e && (this.license = e) } } function Vr(e) { var t; return ge(this, void 0, void 0, (function* () { return !(!(null === (t = e.cloud.options) || void 0 === t ? void 0 : t.databaseUrl) || !e.cloud.schema) && (yield dr(e, e.cloud.options, e.cloud.schema, { justCheckIfNeeded: !0 })) })) } const qr = new WeakMap; function Jr(e, t, n, r) { const o = qr.get(e); if (o) { if (o.pull || "push" === (null == r ? void 0 : r.purpose)) return o.promise; { let i = !1; const s = e.cloud.syncState.subscribe((e => { "pulling" === e.phase && (i = !0) })); return o.promise.then((() => { s.unsubscribe() })).catch((e => (s.unsubscribe(), Promise.reject(e)))).then((() => { if (!i) return Jr(e, t, n, r) })) } } const i = function () { return ge(this, void 0, void 0, (function* () { try { if (yield or(e), e.cloud.isServiceWorkerDB) yield dr(e, t, n, r); else { if (e.cloud.usingServiceWorker) throw Ie(!1), new Error("Internal _syncIfPossible() - invalid precondition - should not have been called."); yield function (e, t, n) { return "undefined" != typeof navigator && navigator.locks ? navigator.locks.request(e.name + "|" + t, (() => n())) : n() }(e, "currentSyncWorker", (() => dr(e, t, n, r))) } qr.delete(e) } catch (t) { throw qr.delete(e), t } })) }(); return qr.set(e, { promise: i, pull: "push" !== (null == r ? void 0 : r.purpose) }), i } function Gr(e, t, n) { let r = null, o = { cancelled: !1 }, i = null, s = null; function a(r, c = 1) { setTimeout((() => { i && clearTimeout(i); const l = "pull" === s ? "pull" : r; i = null, s = null, Jr(e, t, n, { cancelToken: o, retryImmediatelyOnFetchError: !0, purpose: l }).catch((e => { if (o.cancelled) u(); else if (c < 3) { const e = s && "pull" === s ? "pull" : r, t = setTimeout((() => a(e, c + 1)), 6e4 * [0, 5, 15][c]); i && clearTimeout(i), i = t, s = e } })) }), 0) } const u = () => { o.cancelled = !0, r && r.unsubscribe() }; return { start: () => { r = e.localSyncEvent.subscribe((({ purpose: e }) => { try { a(e || "pull") } catch (e) { } })) }, stop: u } } function Zr(e, t) { if (e && t && t.unsyncedTables) for (const n of t.unsyncedTables) e[n] && (e[n].markedForSync = !1) } var Xr, Qr, eo, to, no, ro = {}, oo = [], io = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i; function so(e, t) { for (var n in t) e[n] = t[n]; return e } function ao(e) { var t = e.parentNode; t && t.removeChild(e) } function uo(e, t, n) { var r, o, i, s = {}; for (i in t) "key" == i ? r = t[i] : "ref" == i ? o = t[i] : s[i] = t[i]; if (arguments.length > 2 && (s.children = arguments.length > 3 ? Xr.call(arguments, 2) : n), "function" == typeof e && null != e.defaultProps) for (i in e.defaultProps) void 0 === s[i] && (s[i] = e.defaultProps[i]); return co(e, s, r, o, null) } function co(e, t, n, r, o) { var i = { type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o ? ++eo : o }; return null == o && null != Qr.vnode && Qr.vnode(i), i } function lo(e) { return e.children } function fo(e, t) { this.props = e, this.context = t } function ho(e, t) { if (null == t) return e.__ ? ho(e.__, e.__.__k.indexOf(e) + 1) : null; for (var n; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) return n.__e; return "function" == typeof e.type ? ho(e) : null } function po(e) { var t, n; if (null != (e = e.__) && null != e.__c) { for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) { e.__e = e.__c.base = n.__e; break } return po(e) } } function yo(e) { (!e.__d && (e.__d = !0) && to.push(e) && !vo.__r++ || no !== Qr.debounceRendering) && ((no = Qr.debounceRendering) || setTimeout)(vo) } function vo() { for (var e; vo.__r = to.length;)e = to.sort((function (e, t) { return e.__v.__b - t.__v.__b })), to = [], e.some((function (e) { var t, n, r, o, i, s; e.__d && (i = (o = (t = e).__v).__e, (s = t.__P) && (n = [], (r = so({}, o)).__v = o.__v + 1, Eo(s, o, r, t.__n, void 0 !== s.ownerSVGElement, null != o.__h ? [i] : null, n, null == i ? ho(o) : i, o.__h), Io(n, o), o.__e != i && po(o))) })) } function mo(e, t, n, r, o, i, s, a, u, c) { var l, d, f, h, p, y, v, m = r && r.__k || oo, b = m.length; for (n.__k = [], l = 0; l < t.length; l++)if (null != (h = n.__k[l] = null == (h = t[l]) || "boolean" == typeof h ? null : "string" == typeof h || "number" == typeof h || "bigint" == typeof h ? co(null, h, null, null, h) : Array.isArray(h) ? co(lo, { children: h }, null, null, null) : h.__b > 0 ? co(h.type, h.props, h.key, null, h.__v) : h)) { if (h.__ = n, h.__b = n.__b + 1, null === (f = m[l]) || f && h.key == f.key && h.type === f.type) m[l] = void 0; else for (d = 0; d < b; d++) { if ((f = m[d]) && h.key == f.key && h.type === f.type) { m[d] = void 0; break } f = null } Eo(e, h, f = f || ro, o, i, s, a, u, c), p = h.__e, (d = h.ref) && f.ref != d && (v || (v = []), f.ref && v.push(f.ref, null, h), v.push(d, h.__c || p, h)), null != p ? (null == y && (y = p), "function" == typeof h.type && h.__k === f.__k ? h.__d = u = bo(h, u, e) : u = go(e, h, f, m, p, u), "function" == typeof n.type && (n.__d = u)) : u && f.__e == u && u.parentNode != e && (u = ho(f)) } for (n.__e = y, l = b; l--;)null != m[l] && ("function" == typeof n.type && null != m[l].__e && m[l].__e == n.__d && (n.__d = ho(r, l + 1)), Ao(m[l], m[l])); if (v) for (l = 0; l < v.length; l++)xo(v[l], v[++l], v[++l]) } function bo(e, t, n) { for (var r, o = e.__k, i = 0; o && i < o.length; i++)(r = o[i]) && (r.__ = e, t = "function" == typeof r.type ? bo(r, t, n) : go(n, r, r, o, r.__e, t)); return t } function go(e, t, n, r, o, i) { var s, a, u; if (void 0 !== t.__d) s = t.__d, t.__d = void 0; else if (null == n || o != i || null == o.parentNode) e: if (null == i || i.parentNode !== e) e.appendChild(o), s = null; else { for (a = i, u = 0; (a = a.nextSibling) && u < r.length; u += 2)if (a == o) break e; e.insertBefore(o, i), s = i } return void 0 !== s ? s : o.nextSibling } function _o(e, t, n) { "-" === t[0] ? e.setProperty(t, n) : e[t] = null == n ? "" : "number" != typeof n || io.test(t) ? n : n + "px" } function wo(e, t, n, r, o) { var i; e: if ("style" === t) if ("string" == typeof n) e.style.cssText = n; else { if ("string" == typeof r && (e.style.cssText = r = ""), r) for (t in r) n && t in n || _o(e.style, t, ""); if (n) for (t in n) r && n[t] === r[t] || _o(e.style, t, n[t]) } else if ("o" === t[0] && "n" === t[1]) i = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + i] = n, n ? r || e.addEventListener(t, i ? ko : So, i) : e.removeEventListener(t, i ? ko : So, i); else if ("dangerouslySetInnerHTML" !== t) { if (o) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if ("href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try { e[t] = null == n ? "" : n; break e } catch (e) { } "function" == typeof n || (null != n && (!1 !== n || "a" === t[0] && "r" === t[1]) ? e.setAttribute(t, n) : e.removeAttribute(t)) } } function So(e) { this.l[e.type + !1](Qr.event ? Qr.event(e) : e) } function ko(e) { this.l[e.type + !0](Qr.event ? Qr.event(e) : e) } function Eo(e, t, n, r, o, i, s, a, u) { var c, l, d, f, h, p, y, v, m, b, g, _, w, S = t.type; if (void 0 !== t.constructor) return null; null != n.__h && (u = n.__h, a = t.__e = n.__e, t.__h = null, i = [a]), (c = Qr.__b) && c(t); try { e: if ("function" == typeof S) { if (v = t.props, m = (c = S.contextType) && r[c.__c], b = c ? m ? m.props.value : c.__ : r, n.__c ? y = (l = t.__c = n.__c).__ = l.__E : ("prototype" in S && S.prototype.render ? t.__c = l = new S(v, b) : (t.__c = l = new fo(v, b), l.constructor = S, l.render = To), m && m.sub(l), l.props = v, l.state || (l.state = {}), l.context = b, l.__n = r, d = l.__d = !0, l.__h = []), null == l.__s && (l.__s = l.state), null != S.getDerivedStateFromProps && (l.__s == l.state && (l.__s = so({}, l.__s)), so(l.__s, S.getDerivedStateFromProps(v, l.__s))), f = l.props, h = l.state, d) null == S.getDerivedStateFromProps && null != l.componentWillMount && l.componentWillMount(), null != l.componentDidMount && l.__h.push(l.componentDidMount); else { if (null == S.getDerivedStateFromProps && v !== f && null != l.componentWillReceiveProps && l.componentWillReceiveProps(v, b), !l.__e && null != l.shouldComponentUpdate && !1 === l.shouldComponentUpdate(v, l.__s, b) || t.__v === n.__v) { l.props = v, l.state = l.__s, t.__v !== n.__v && (l.__d = !1), l.__v = t, t.__e = n.__e, t.__k = n.__k, t.__k.forEach((function (e) { e && (e.__ = t) })), l.__h.length && s.push(l); break e } null != l.componentWillUpdate && l.componentWillUpdate(v, l.__s, b), null != l.componentDidUpdate && l.__h.push((function () { l.componentDidUpdate(f, h, p) })) } if (l.context = b, l.props = v, l.__v = t, l.__P = e, g = Qr.__r, _ = 0, "prototype" in S && S.prototype.render) l.state = l.__s, l.__d = !1, g && g(t), c = l.render(l.props, l.state, l.context); else do { l.__d = !1, g && g(t), c = l.render(l.props, l.state, l.context), l.state = l.__s } while (l.__d && ++_ < 25); l.state = l.__s, null != l.getChildContext && (r = so(so({}, r), l.getChildContext())), d || null == l.getSnapshotBeforeUpdate || (p = l.getSnapshotBeforeUpdate(f, h)), w = null != c && c.type === lo && null == c.key ? c.props.children : c, mo(e, Array.isArray(w) ? w : [w], t, n, r, o, i, s, a, u), l.base = t.__e, t.__h = null, l.__h.length && s.push(l), y && (l.__E = l.__ = null), l.__e = !1 } else null == i && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = function (e, t, n, r, o, i, s, a) { var u, c, l, d = n.props, f = t.props, h = t.type, p = 0; if ("svg" === h && (o = !0), null != i) for (; p < i.length; p++)if ((u = i[p]) && "setAttribute" in u == !!h && (h ? u.localName === h : 3 === u.nodeType)) { e = u, i[p] = null; break } if (null == e) { if (null === h) return document.createTextNode(f); e = o ? document.createElementNS("http://www.w3.org/2000/svg", h) : document.createElement(h, f.is && f), i = null, a = !1 } if (null === h) d === f || a && e.data === f || (e.data = f); else { if (i = i && Xr.call(e.childNodes), c = (d = n.props || ro).dangerouslySetInnerHTML, l = f.dangerouslySetInnerHTML, !a) { if (null != i) for (d = {}, p = 0; p < e.attributes.length; p++)d[e.attributes[p].name] = e.attributes[p].value; (l || c) && (l && (c && l.__html == c.__html || l.__html === e.innerHTML) || (e.innerHTML = l && l.__html || "")) } if (function (e, t, n, r, o) { var i; for (i in n) "children" === i || "key" === i || i in t || wo(e, i, null, n[i], r); for (i in t) o && "function" != typeof t[i] || "children" === i || "key" === i || "value" === i || "checked" === i || n[i] === t[i] || wo(e, i, t[i], n[i], r) }(e, f, d, o, a), l) t.__k = []; else if (p = t.props.children, mo(e, Array.isArray(p) ? p : [p], t, n, r, o && "foreignObject" !== h, i, s, i ? i[0] : n.__k && ho(n, 0), a), null != i) for (p = i.length; p--;)null != i[p] && ao(i[p]); a || ("value" in f && void 0 !== (p = f.value) && (p !== e.value || "progress" === h && !p || "option" === h && p !== d.value) && wo(e, "value", p, d.value, !1), "checked" in f && void 0 !== (p = f.checked) && p !== e.checked && wo(e, "checked", p, d.checked, !1)) } return e }(n.__e, t, n, r, o, i, s, u); (c = Qr.diffed) && c(t) } catch (e) { t.__v = null, (u || null != i) && (t.__e = a, t.__h = !!u, i[i.indexOf(a)] = null), Qr.__e(e, t, n) } } function Io(e, t) { Qr.__c && Qr.__c(t, e), e.some((function (t) { try { e = t.__h, t.__h = [], e.some((function (e) { e.call(t) })) } catch (e) { Qr.__e(e, t.__v) } })) } function xo(e, t, n) { try { "function" == typeof e ? e(t) : e.current = t } catch (e) { Qr.__e(e, n) } } function Ao(e, t, n) { var r, o; if (Qr.unmount && Qr.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || xo(r, null, t)), null != (r = e.__c)) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (e) { Qr.__e(e, t) } r.base = r.__P = null } if (r = e.__k) for (o = 0; o < r.length; o++)r[o] && Ao(r[o], t, "function" != typeof e.type); n || null == e.__e || ao(e.__e), e.__e = e.__d = void 0 } function To(e, t, n) { return this.constructor(e, n) } function Oo(e, t, n) { var r, o, i; Qr.__ && Qr.__(e, t), o = (r = "function" == typeof n) ? null : n && n.__k || t.__k, i = [], Eo(t, e = (!r && n || t).__k = uo(lo, null, [e]), o || ro, ro, void 0 !== t.ownerSVGElement, !r && n ? [n] : o ? null : t.firstChild ? Xr.call(t.childNodes) : null, i, !r && n ? n : o ? o.__e : t.firstChild, r), Io(i, e) } Xr = oo.slice, Qr = { __e: function (e, t, n, r) { for (var o, i, s; t = t.__;)if ((o = t.__c) && !o.__) try { if ((i = o.constructor) && null != i.getDerivedStateFromError && (o.setState(i.getDerivedStateFromError(e)), s = o.__d), null != o.componentDidCatch && (o.componentDidCatch(e, r || {}), s = o.__d), s) return o.__E = o } catch (t) { e = t } throw e } }, eo = 0, fo.prototype.setState = function (e, t) { var n; n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = so({}, this.state), "function" == typeof e && (e = e(so({}, n), this.props)), e && so(n, e), null != e && this.__v && (t && this.__h.push(t), yo(this)) }, fo.prototype.forceUpdate = function (e) { this.__v && (this.__e = !0, e && this.__h.push(e), yo(this)) }, fo.prototype.render = lo, to = [], vo.__r = 0; const Po = { Error: { color: "red" }, Alert: { error: { color: "red", fontWeight: "bold" }, warning: { color: "#f80", fontWeight: "bold" }, info: { color: "black" } }, Darken: { position: "fixed", top: 0, left: 0, opacity: .5, backgroundColor: "#000", width: "100vw", height: "100vh", zIndex: 150, webkitBackdropFilter: "blur(2px)", backdropFilter: "blur(2px)" }, DialogOuter: { position: "fixed", top: 0, left: 0, width: "100vw", height: "100vh", zIndex: 150, alignItems: "center", display: "flex", justifyContent: "center" }, DialogInner: { position: "relative", color: "#222", backgroundColor: "#fff", padding: "30px", marginBottom: "2em", maxWidth: "90%", maxHeight: "90%", overflowY: "auto", border: "3px solid #3d3d5d", borderRadius: "8px", boxShadow: "0 0 80px 10px #666", width: "auto", fontFamily: "sans-serif" }, Input: { height: "35px", width: "17em", borderColor: "#ccf4", outline: "none", fontSize: "17pt", padding: "8px" } }; function Co({ children: e, className: t }) { return uo("div", { className: t }, uo("div", { style: Po.Darken }), uo("div", { style: Po.DialogOuter }, uo("div", { style: Po.DialogInner }, e))) } var Uo, Ro, jo, Lo, Do = 0, $o = [], No = [], Bo = Qr.__b, Mo = Qr.__r, Wo = Qr.diffed, Fo = Qr.__c, Yo = Qr.unmount; function Ko(e, t) { Qr.__h && Qr.__h(Ro, e, Do || t), Do = 0; var n = Ro.__H || (Ro.__H = { __: [], __h: [] }); return e >= n.__.length && n.__.push({ __V: No }), n.__[e] } function zo() { for (var e; e = $o.shift();)if (e.__P && e.__H) try { e.__H.__h.forEach(Vo), e.__H.__h.forEach(qo), e.__H.__h = [] } catch (t) { e.__H.__h = [], Qr.__e(t, e.__v) } } Qr.__b = function (e) { Ro = null, Bo && Bo(e) }, Qr.__r = function (e) { Mo && Mo(e), Uo = 0; var t = (Ro = e.__c).__H; t && (jo === Ro ? (t.__h = [], Ro.__h = [], t.__.forEach((function (e) { e.__N && (e.__ = e.__N), e.__V = No, e.__N = e.i = void 0 }))) : (t.__h.forEach(Vo), t.__h.forEach(qo), t.__h = [])), jo = Ro }, Qr.diffed = function (e) { Wo && Wo(e); var t = e.__c; t && t.__H && (t.__H.__h.length && (1 !== $o.push(t) && Lo === Qr.requestAnimationFrame || ((Lo = Qr.requestAnimationFrame) || function (e) { var t, n = function () { clearTimeout(r), Ho && cancelAnimationFrame(t), setTimeout(e) }, r = setTimeout(n, 100); Ho && (t = requestAnimationFrame(n)) })(zo)), t.__H.__.forEach((function (e) { e.i && (e.__H = e.i), e.__V !== No && (e.__ = e.__V), e.i = void 0, e.__V = No }))), jo = Ro = null }, Qr.__c = function (e, t) { t.some((function (e) { try { e.__h.forEach(Vo), e.__h = e.__h.filter((function (e) { return !e.__ || qo(e) })) } catch (n) { t.some((function (e) { e.__h && (e.__h = []) })), t = [], Qr.__e(n, e.__v) } })), Fo && Fo(e, t) }, Qr.unmount = function (e) { Yo && Yo(e); var t, n = e.__c; n && n.__H && (n.__H.__.forEach((function (e) { try { Vo(e) } catch (e) { t = e } })), t && Qr.__e(t, n.__v)) }; var Ho = "function" == typeof requestAnimationFrame; function Vo(e) { var t = Ro, n = e.__c; "function" == typeof n && (e.__c = void 0, n()), Ro = t } function qo(e) { var t = Ro; e.__c = e.__(), Ro = t } function Jo(e, t) { return !e || e.length !== t.length || t.some((function (t, n) { return t !== e[n] })) } function Go(e, t) { return "function" == typeof t ? t(e) : t } function Zo({ message: e, messageCode: t, messageParams: n }) { return e.replace(/\{\w+\}/gi, (e => n[e.substring(1, e.length - 1)])) } function Xo({ title: e, type: t, alerts: n, fields: r, submitLabel: o, cancelLabel: i, onCancel: s, onSubmit: a }) { const [u, c] = function (e) { return Do = 1, function (e, t) { var n = Ko(Uo++, 2); if (n.t = e, !n.__c && (n.__ = [Go(void 0, t), function (e) { var t = n.__N ? n.__N[0] : n.__[0], r = n.t(t, e); t !== r && (n.__N = [r, n.__[1]], n.__c.setState({})) }], n.__c = Ro, !Ro.u)) { Ro.u = !0; var r = Ro.shouldComponentUpdate; Ro.shouldComponentUpdate = function (e, t, o) { if (!n.__c.__H) return !0; var i = n.__c.__H.__.filter((function (e) { return e.__c })); if (i.every((function (e) { return !e.__N }))) return !r || r.call(this, e, t, o); var s = !1; return i.forEach((function (e) { if (e.__N) { var t = e.__[0]; e.__ = e.__N, e.__N = void 0, t !== e.__[0] && (s = !0) } })), !!s && (!r || r.call(this, e, t, o)) } } return n.__N || n.__ }(Go, e) }({}), l = function (e) { return Do = 5, function (e, t) { var n = Ko(Uo++, 7); return Jo(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__ }((function () { return { current: e } }), []) }(null); return function (e, t) { var n = Ko(Uo++, 4); !Qr.__s && Jo(n.__H, t) && (n.__ = () => { var e; return null === (e = l.current) || void 0 === e ? void 0 : e.focus() }, n.i = t, Ro.__h.push(n)) }(0, []), uo(Co, { className: "dxc-login-dlg" }, uo(lo, null, uo("h3", { style: Po.WindowHeader }, e), n.map((e => uo("p", { style: Po.Alert[e.type] }, Zo(e)))), uo("form", { onSubmit: e => { e.preventDefault(), a(u) } }, Object.entries(r).map((([e, { type: t, label: n, placeholder: r }], o) => uo("label", { style: Po.Label, key: o }, n ? `${n}: ` : "", uo("input", { ref: 0 === o ? l : void 0, type: t, name: e, autoComplete: "on", style: Po.Input, autoFocus: !0, placeholder: r, value: u[e] || "", onInput: n => { var r; const o = function (e, t) { switch (e) { case "email": return t.toLowerCase(); case "otp": return t.toUpperCase(); default: return t } }(t, null === (r = n.target) || void 0 === r ? void 0 : r.value); let i = Object.assign(Object.assign({}, u), { [e]: o }); c(i), "otp" === t && 8 === (null == o ? void 0 : o.trim().length) && a(i) } })))))), uo("div", { style: Po.ButtonsDiv }, uo(lo, null, uo("button", { type: "submit", style: Po.Button, onClick: () => a(u) }, o), i && uo("button", { style: Po.Button, onClick: s }, i)))) } class Qo extends fo { constructor(e) { super(e), this.observer = e => this.setState({ userInteraction: e }), this.state = { userInteraction: void 0 } } componentDidMount() { this.subscription = d(this.props.db.cloud.userInteraction).subscribe(this.observer) } componentWillUnmount() { this.subscription && (this.subscription.unsubscribe(), delete this.subscription) } render(e, { userInteraction: t }) { return t ? uo(Xo, Object.assign({}, t)) : null } } function ei(e) { const t = new WeakMap; return n => { let r = t.get(n); return r || (r = e(n), t.set(n, r)), r } } const ti = ei((e => new o(un))); function ni(e, t) { let n = t, r = d(e).pipe(y((e => n = e)), m({ resetOnRefCountZero: () => b(1e3) })); const o = new h((e => { let t = !1; const o = r.subscribe({ next(n) { t = !0, e.next(n) }, error(t) { e.error(t) }, complete() { e.complete() } }); return t || o.closed || e.next(n), o })); return o.getValue = () => n, o } const ri = ei((e => ni(n((() => e.roles.where({ realmId: "rlm-public" }).toArray().then((e => { const t = {}; for (const n of e.slice().sort(((e, t) => (e.sortOrder || 0) - (t.sortOrder || 0)))) t[n.name] = n; return t })))), {}))), oi = ei((e => ni(ti(e._novip).pipe(zt((t => n((() => e.transaction("r", "realms", "members", (() => Promise.all([e.members.where({ userId: t.userId }).toArray(), e.realms.toArray(), t.userId]).then((([e, t, n]) => ({ selfMembers: e, realms: t, userId: n })))))))))), { selfMembers: [], realms: [], get userId() { return e.cloud.currentUserId } }))); function ii(...e) { if (0 === e.length) return {}; return e.reduce(((e, t) => { const n = Object.assign({}, e); for (const [e, r] of Object.entries(t)) if (e in n && n[e]) { if ("*" === n[e]) continue; if ("*" === r) n[e] = "*"; else if (Array.isArray(r) && Array.isArray(n[e])) { const t = n, o = t[e]; t[e] = [...new Set([...o, ...r])] } else if ("object" == typeof r && r && "object" == typeof n[e]) { const t = n[e]; for (const [e, n] of Object.entries(r)) "*" !== t[e] && ("*" === n ? t[e] = "*" : Array.isArray(t[e]) && Array.isArray(n) && (t[e] = [...new Set([...t[e], ...n])])) } } else n[e] = t[e]; return n })) } const si = ei((e => function (e, t) { let n; const r = e.pipe(y((e => n = t(e)))); return r.getValue = () => void 0 !== n ? n : n = t(e.getValue()), r }(ni(c([oi(e._novip), ri(e._novip)]).pipe(Ut((([{ selfMembers: e, realms: t, userId: n }, r]) => ({ selfMembers: e, realms: t, userId: n, globalRoles: r })))), { selfMembers: [], realms: [], userId: un.userId, globalRoles: {} }), (({ selfMembers: e, realms: t, userId: n, globalRoles: r }) => t.map((t => { const o = e.filter((e => e.realmId === t.realmId)), i = o.map((e => e.permissions)).filter((e => e)), s = In(o.map((e => e.roles)).filter((e => e))).map((e => r[e])).filter((e => e)).map((e => e.permissions)); return Object.assign(Object.assign({}, t), { permissions: t.owner === n ? { manage: "*" } : ii(...i, ...s) }) })).reduce(((e, t) => Object.assign(Object.assign({}, e), { [t.realmId]: t })), { [n]: { realmId: n, owner: n, name: n, permissions: { manage: "*" } } }))))); class ai { constructor(e, t, n) { this.permissions = e || {}, this.tableName = t, this.isOwner = n } add(...e) { var t; return "*" === this.permissions.manage || !!(null === (t = this.permissions.manage) || void 0 === t ? void 0 : t.includes(this.tableName)) || "*" === this.permissions.add || !!e.every((e => { var t; return null === (t = this.permissions.add) || void 0 === t ? void 0 : t.includes(e) })) } update(...e) { var t, n; if (this.isOwner || "*" === this.permissions.manage) return !0; if (null === (t = this.permissions.manage) || void 0 === t ? void 0 : t.includes(this.tableName)) return !0; if ("*" === this.permissions.update) return e.every((e => "owner" !== e)); const r = null === (n = this.permissions.update) || void 0 === n ? void 0 : n[this.tableName]; return "*" === r ? e.every((e => "owner" !== e)) : e.every((e => null == r ? void 0 : r.some((t => t === e || "*" === t && "owner" !== e)))) } delete() { var e; return !(!this.isOwner && "*" !== this.permissions.manage && !(null === (e = this.permissions.manage) || void 0 === e ? void 0 : e.includes(this.tableName))) } } const ui = ei((e => { const t = ti(e._novip).pipe(zt((t => n((() => e.members.where({ email: t.email || "" }).toArray()))))), r = si(e._novip), o = oi(e._novip); return ni(c([t, o, r]).pipe(Ut((([t, n, r]) => { const o = (e, t) => Object.assign(Object.assign({}, e), { [t.id]: Object.assign(Object.assign({}, t), { realm: r[t.realmId] }) }), i = t.reduce(o, {}), s = n.selfMembers.reduce(o, i); return Object.values(s).filter((e => !e.accepted)).map((t => Object.assign(Object.assign({}, t), { accept() { return ge(this, void 0, void 0, (function* () { yield e.members.update(t.id, { accepted: new Date }) })) }, reject() { return ge(this, void 0, void 0, (function* () { yield e.members.update(t.id, { rejected: new Date }) })) } }))) }))), []) })); function ci(e) { return "rlm~" + e } function li(e) { return e.startsWith("rlm~") ? e.substr(4) : null } const di = { nameSuffix: !0 }; function fi(t) { const r = t.name, a = ti(t), h = []; let p = !1, y = null; t.on("ready", (t => ge(this, void 0, void 0, (function* () { try { yield function (t) { var r, u, g, _, w, S, k; return ge(this, void 0, void 0, (function* () { v = !1; const E = br(t); "undefined" != typeof window && "undefined" != typeof document && ((null === (r = E.cloud.options) || void 0 === r ? void 0 : r.customLoginGui) || h.push(function (e) { let t = !1; const n = document.createElement("div"); return document.body ? (document.body.appendChild(n), Oo(uo(Qo, { db: e.vip }), n)) : addEventListener("DOMContentLoaded", (() => { t || (document.body.appendChild(n), Oo(uo(Qo, { db: e.vip }), n)) })), { unsubscribe() { try { n.remove() } catch (e) { } t = !0 }, get closed() { return t } } }(t))), E.cloud.isServiceWorkerDB || h.push(function (e) { let t = e.cloud.webSocketStatus.value; const n = e.cloud.webSocketStatus.pipe(zt((e => { const n = t; t = e; const r = s(e); switch (e) { case "disconnected": return Dr.value ? r.pipe(jt(500)) : r; case "connecting": return "not-started" === n || "error" === n ? r : r.pipe(jt(4e3)); default: return r } }))); return c([n, e.syncStateChangedEvent.pipe(Kt({ phase: "initial" })), ti(e.dx._novip), $r]).pipe(Ut((([t, n, r, o]) => { var i; if ((null === (i = r.license) || void 0 === i ? void 0 : i.status) && "ok" !== r.license.status) return { phase: "offline", status: "offline", license: r.license.status }; let { phase: s, error: a, progress: u } = n, c = t; return "error" === s && (c = "error"), "not-started" === t && ("pushing" !== s && "pulling" !== s || (c = "connecting")), "error" !== e.cloud.syncState.value.phase || "pushing" !== n.phase && "pulling" !== n.phase || (c = "connecting"), o || (c = "disconnected"), { phase: s, error: a, progress: u, status: sr ? c : "offline", license: "ok" } }))) }(E).subscribe(t.cloud.syncState)), h.push(E.syncCompleteEvent.subscribe(b)), E.tables.every((e => e.core)) || Er(); const I = "serviceWorker" in navigator ? yield navigator.serviceWorker.getRegistrations() : [], [x, A] = yield E.transaction("rw", E.$syncState, (() => ge(this, void 0, void 0, (function* () { var e, t; const { options: n, schema: r } = E.cloud, [o, i, s] = yield Promise.all([E.getOptions(), E.getSchema(), E.getPersistedSyncState()]); if (p) { if (!o || JSON.stringify(o) !== JSON.stringify(n)) { if (!n) throw new Error("Internal error"); const e = Object.assign({}, n); delete e.fetchTokens, yield E.$syncState.put(e, "options") } } else E.cloud.options = o || null; if ((null === (e = E.cloud.options) || void 0 === e ? void 0 : e.tryUseServiceWorker) && "serviceWorker" in navigator && I.length > 0 && !Sr ? E.cloud.usingServiceWorker = !0 : ((null === (t = E.cloud.options) || void 0 === t ? void 0 : t.tryUseServiceWorker) && E.cloud.isServiceWorkerDB, E.cloud.usingServiceWorker = !1), Zr(r, E.cloud.options), Zr(i, E.cloud.options), r) { if (!i || JSON.stringify(i) !== JSON.stringify(r)) { const e = i || {}; for (const [t, n] of Object.entries(r)) { const r = e[t]; r ? (r.markedForSync = n.markedForSync, n.deleted = r.deleted, r.generatedGlobalId = n.generatedGlobalId) : e[t] = Object.assign({}, n) } yield E.$syncState.put(e, "schema"), Object.assign(r, e) } } else E.cloud.schema = i || null; return [null == s ? void 0 : s.initiallySynced, null == s ? void 0 : s.realms] })))); x && E.setInitiallySynced(!0), function (t) { var n, r; for (const o of t.tables) if (null === (r = null === (n = t.cloud.schema) || void 0 === n ? void 0 : n[o.name]) || void 0 === r ? void 0 : r.markedForSync) { if (o.schema.primKey.auto) throw new e.SchemaError(`Table ${o.name} is both autoIncremented and synced. Use db.cloud.configure({unsyncedTables: [${JSON.stringify(o.name)}]}) to blacklist it from sync`); if (!o.schema.primKey.keyPath) throw new e.SchemaError(`Table ${o.name} cannot be both synced and outbound. Use db.cloud.configure({unsyncedTables: [${JSON.stringify(o.name)}]}) to blacklist it from sync`) } }(E), (null === (u = E.cloud.options) || void 0 === u ? void 0 : u.databaseUrl) && !x && (yield function (e, t, n) { return ge(this, void 0, void 0, (function* () { yield dr(e, t, n, { isInitialSync: !0 }) })) }(E, E.cloud.options, E.cloud.schema), E.setInitiallySynced(!0)), m(), E.cloud.isServiceWorkerDB || (h.push(n((() => E.getCurrentUser())).subscribe(a)), h.push(n((() => E.getPersistedSyncState())).subscribe(E.cloud.persistedSyncState)), yield l(c([a.pipe(Yt(1), $t(1)), E.cloud.persistedSyncState.pipe(Yt(1), $t(1))]))); let T = !1; const O = yield E.getCurrentUser(), P = null === (g = E.cloud.options) || void 0 === g ? void 0 : g.requireAuth; P && ("object" == typeof P ? (!O.isLoggedIn || P.userId && O.userId !== P.userId || P.email && O.email !== P.email) && (T = yield pn(E, P)) : O.isLoggedIn || (T = yield pn(E))), !O.isLoggedIn || A && A.includes(O.userId) || (T = !0), y && y.stop(), y = null, m(), E.cloud.usingServiceWorker && (null === (_ = E.cloud.options) || void 0 === _ ? void 0 : _.databaseUrl) ? (Vt(E, T ? "pull" : "push").catch((() => { })), function (e) { var t; return ge(this, void 0, void 0, (function* () { try { const { periodicSync: n } = yield navigator.serviceWorker.ready; if (n) try { yield n.register(`dexie-cloud:${e.name}`, null === (t = e.cloud.options) || void 0 === t ? void 0 : t.periodicSync) } catch (e) { } } catch (e) { } })) }(E).catch((() => { }))) : (null === (w = E.cloud.options) || void 0 === w ? void 0 : w.databaseUrl) && E.cloud.schema && !E.cloud.isServiceWorkerDB && (y = Gr(E, E.cloud.options, E.cloud.schema), y.start(), qt(E, T ? "pull" : "push")), m(), E.cloud.isServiceWorkerDB || h.push(i(self, "online").subscribe((() => { E.syncStateChangedEvent.next({ phase: "not-in-sync" }), Lr(E) || qt(E, "push") })), i(self, "offline").subscribe((() => { E.syncStateChangedEvent.next({ phase: "offline" }) }))), !(null === (S = E.cloud.options) || void 0 === S ? void 0 : S.databaseUrl) || (null === (k = E.cloud.options) || void 0 === k ? void 0 : k.disableWebSocket) || kr || h.push(function (e) { var t; if (!(null === (t = e.cloud.options) || void 0 === t ? void 0 : t.databaseUrl)) throw new Error("No database URL to connect WebSocket to"); const n = e.messageConsumer.readyToServe.pipe(Ft((e => e)), zt((() => e.getPersistedSyncState())), Ft((e => e && e.serverRevision)), zt((e => ge(this, void 0, void 0, (function* () { return { type: "ready", rev: e.serverRevision, realmSetHash: yield _n(e) } }))))); return function t() { return e.cloud.persistedSyncState.pipe(Ft((e => null == e ? void 0 : e.serverRevision)), $t(1), zt((t => e.cloud.currentUser.pipe(Ut((e => [e, t]))))), zt((([e, t]) => $r.pipe(Ut((n => [n ? e : null, t]))))), zt((([t, n]) => (null == t ? void 0 : t.isLoggedIn) && !(null == n ? void 0 : n.realms.includes(t.userId)) ? e.cloud.persistedSyncState.pipe(Ft((e => (null == e ? void 0 : e.realms.includes(t.userId)) || !1)), $t(1), Ut((e => [t, e]))) : new o([t, n]))), zt((([e, t]) => ge(this, void 0, void 0, (function* () { return [e, yield _n(t)] })))), Mt((([e, t], [n, r]) => e === n && t === r)), zt((([r, o]) => { var i; return (null === (i = e.cloud.persistedSyncState) || void 0 === i ? void 0 : i.value) ? r ? new Yr(e.cloud.options.databaseUrl, e.cloud.persistedSyncState.value.serverRevision, o, e.cloud.persistedSyncState.value.clientIdentity, n, e.cloud.webSocketStatus, r.accessToken, r.accessTokenExpiration) : d([]) : t() })), Tt((n => "TokenExpiredError" === (null == n ? void 0 : n.name) ? s(!0).pipe(zt((() => ge(this, void 0, void 0, (function* () { const t = yield e.getCurrentUser(), n = yield on(e.cloud.options.databaseUrl, t); yield e.table("$logins").update(t.userId, { accessToken: n.accessToken, accessTokenExpiration: n.accessTokenExpiration, claims: n.claims, license: n.license, data: n.data }) })))), zt((() => t()))) : f((() => n)))), Tt((n => (e.cloud.webSocketStatus.next("error"), n instanceof Hr ? f((() => n)) : d(function () { return ge(this, void 0, void 0, (function* () { yield new Promise((e => setTimeout(e, 3e3))), yield l(Wr) })) }()).pipe(zt((() => t()))))))) }().subscribe({ next: t => { t && e.messageConsumer.enqueue(t) }, error: e => { }, complete: () => { } }) }(E)) })) }(t) } catch (e) { } }))), !0); let v = !1; function m() { if (v) throw new e.DatabaseClosedError } !function (e, t) { e.on.close.subscribe(t); const n = e._close; e._close = function () { n.call(this), t() } }(t, (() => { h.forEach((e => e.unsubscribe())), v = !0, y && y.stop(), y = null, a.next(un) })); const b = new u; var g; t.cloud = { version: "4.0.11", options: Object.assign({}, di), schema: null, get currentUserId() { return a.value.userId || un.userId }, currentUser: a, syncState: new o({ phase: "initial", status: "not-started" }), events: { syncComplete: b }, persistedSyncState: new o(void 0), userInteraction: new o(void 0), webSocketStatus: new o("not-started"), login(e) { return ge(this, void 0, void 0, (function* () { const n = br(t); yield n.cloud.sync(), yield pn(n, e) })) }, invites: ui(t), roles: ri(t), configure(e) { e = t.cloud.options = Object.assign(Object.assign({}, t.cloud.options), e), p = !0, e.databaseUrl && e.nameSuffix && (t.name = `${r}-${function (e) { const t = new URL(e); return "/" === t.pathname ? t.hostname.split(".")[0] : t.pathname.split("/")[1] }(e.databaseUrl)}`, br(t).reconfigure()), Zr(t.cloud.schema, t.cloud.options) }, logout({ force: e } = {}) { return ge(this, void 0, void 0, (function* () { e ? yield dn(br(t), { deleteUnsyncedData: !0 }) : yield ln(br(t)) })) }, sync({ wait: e, purpose: r } = { wait: !0, purpose: "push" }) { var o; return ge(this, void 0, void 0, (function* () { void 0 === e && (e = !0); const i = br(t); if ("ok" !== ((null === (o = i.cloud.currentUser.value.license) || void 0 === o ? void 0 : o.status) || "ok") && (yield nn(i)), "pull" === r) { const t = i.cloud.persistedSyncState.value; if (qt(i, r), e) { const e = yield l(i.cloud.persistedSyncState.pipe(Ft((e => null != (null == e ? void 0 : e.timestamp) && (!t || e.timestamp > t.timestamp))))); if (null == e ? void 0 : e.error) throw new Error("Sync error: " + e.error) } } else if (yield Vr(i)) { const t = i.cloud.persistedSyncState.value; qt(i, r), e && (yield l(d(n((() => ge(this, void 0, void 0, (function* () { const e = yield Vr(i), n = yield i.getPersistedSyncState(); if ((null == n ? void 0 : n.timestamp) !== (null == t ? void 0 : t.timestamp) && (null == n ? void 0 : n.error)) throw new Error("Sync error: " + n.error); return e }))))).pipe(Ft((e => !e))))) } })) }, permissions: (e, n) => function (e, t, n) { if (!t) throw new TypeError("Cannot check permissions of undefined or null. A Dexie Cloud object with realmId and owner expected."); const { owner: r, realmId: o } = t; if (!n) { if ("function" != typeof t.table) throw new TypeError("Missing 'table' argument to permissions and table could not be extracted from entity"); n = t.table() } const i = si(e), s = t => { const i = t[o || e.cloud.currentUserId]; return i ? new ai(i.permissions, n, void 0 === o || o === e.cloud.currentUserId || r === e.cloud.currentUserId) : new ai({}, n, !r || r === e.cloud.currentUserId) }, a = i.pipe(Ut(s)); return a.getValue = () => s(i.getValue()), a }(t._novip, e, n) }, t.Version.prototype._parseStoresSpec = e.override(t.Version.prototype._parseStoresSpec, (e => function (e, t) { return function (n, r) { const o = Object.assign(Object.assign({}, vr), n); Object.keys(vr).forEach((e => { const t = o[e]; if (null == t) throw new Error(`Cannot delete table ${e} as it is needed for access control of Dexie Cloud`); if (!n[e]) return; const r = t.split(",").map((e => e.trim())), i = vr[e].split(",").map((e => e.trim())), s = new Set(r.map((e => e.replace(/([&*]|\+\+)/g, "")))); if (r[0] !== i[0]) throw new Error(`Cannot override primary key of table ${e}. Please declare it as {${e}: ${JSON.stringify(vr[e])}`); for (let t = 1; t < i.length; ++t) { const n = i[t]; s.has(n.replace(/([&*]|\+\+)/g, "")) || (o[e] += `,${n}`) } })); const i = t.cloud.schema || (t.cloud.schema = {}), s = new Set; return Object.keys(o).forEach((e => { const t = o[e], n = i[e] || (i[e] = {}); null != t ? (/^\@/.test(t) && (o[e] = o[e].substr(1), n.generatedGlobalId = !0, n.idPrefix = function (e, t) { let n = e[0].toLocaleLowerCase(); for (let t = 1, o = e.length; t < o && n.length < 3; ++t)(Tr.test(e[t]) || (r = e[t]) >= "A" && r <= "Z") && (n += e[t].toLowerCase()); for (var r, o, i; t.has(n);) { if (/\d/g.test(n)) { if (n = n.substr(0, n.length - 1) + (n[n.length - 1] + 1), !(n.length > 3)) continue; n = n.substr(0, 3) } else if (n.length < 3) { n += "2"; continue } let e = 1, r = n; for (; t.has(r) && e < 8;)o = n, r = (1 & (i = e) ? o[0].toUpperCase() : o[0].toLowerCase()) + (2 & i ? o[1].toUpperCase() : o[1].toLowerCase()) + (4 & i ? o[2].toUpperCase() : o[2].toLowerCase()), ++e; if (e < 8) n = r; else { let e = n.charCodeAt(2) + 1 & 127; n = n.substr(0, 2) + String.fromCharCode(e) } } return n }(e, s), s.add(n.idPrefix)), /^\$/.test(e) || (o[`$${e}_mutations`] = "++rev", n.markedForSync = !0), n.deleted && (n.deleted = !1)) : (n.deleted = !0, n.markedForSync = !1, o[`$${e}_mutations`] = null) })), e.call(this, o, r) } }(e, t))), t.Table.prototype.newId = function ({ colocateWith: e } = {}) { const n = e && e.substr(e.length - 3); return Pr(t.cloud.schema[this.name].idPrefix || "", n) }, t.Table.prototype.idPrefix = function () { var e, t; return (null === (t = null === (e = this.db.cloud.schema) || void 0 === e ? void 0 : e[this.name]) || void 0 === t ? void 0 : t.idPrefix) || "" }, t.use(function ({ currentUserObservable: e, db: t }) { return { stack: "dbcore", name: "MutationTrackingMiddleware", level: 1, create: n => { const r = n.schema.tables.filter((e => !/^\$/.test(e.name))); let o; try { o = new Map(r.map((e => [e.name, n.table(`$${e.name}_mutations`)]))) } catch (e) { Er() } return Object.assign(Object.assign({}, n), { transaction: (r, o) => { let i; if ("readwrite" === o) { const e = r.filter((e => { var n, r; return null === (r = null === (n = t.cloud.schema) || void 0 === n ? void 0 : n[e]) || void 0 === r ? void 0 : r.markedForSync })).map((e => Sn(e))); i = n.transaction([...r, ...e], o) } else i = n.transaction(r, o); if ("readwrite" === o) { i.txid = An(16), i.opCount = 0, i.currentUser = e.value, jr.value.add(i), jr.next(jr.value); const n = () => { i.removeEventListener("complete", r), i.removeEventListener("error", n), i.removeEventListener("abort", n), jr.value.delete(i), jr.next(jr.value) }, r = () => { i.mutationsAdded && !Lr(t) && qt(t, "push"), n() }; i.addEventListener("complete", r), i.addEventListener("error", n), i.addEventListener("abort", n) } return i }, table: e => { const r = n.table(e); if (/^\$/.test(e)) return e.endsWith("_mutations") ? Object.assign(Object.assign({}, r), { mutate: e => ("add" !== e.type && "put" !== e.type || (e.trans.mutationsAdded = !0), r.mutate(e)) }) : "$logins" === e ? Object.assign(Object.assign({}, r), { mutate: e => r.mutate(e).then((t => (e.trans.mutationsAdded = !0, t))).catch((e => Promise.reject(e))) }) : r; const { schema: i } = r, s = o.get(e); return function (e) { const t = "$lock" + ++Cr; return Object.assign(Object.assign({}, e), { count: Ur(e.count, t), get: Ur(e.get, t), getMany: Ur(e.getMany, t), openCursor: Ur(e.openCursor, t), query: Ur(e.query, t), mutate: Rr(e.mutate, t) }) }(Object.assign(Object.assign({}, r), { mutate: n => { var o, s, u; const c = n.trans; return c.txid ? c.disableChangeTracking ? r.mutate(n) : (null === (s = null === (o = t.cloud.schema) || void 0 === o ? void 0 : o[e]) || void 0 === s ? void 0 : s.markedForSync) && (null === (u = c.currentUser) || void 0 === u ? void 0 : u.isLoggedIn) ? "deleteRange" === n.type ? r.query({ query: { range: n.range, index: i.primaryKey }, trans: n.trans, values: !1 }).then((e => a({ type: "delete", keys: e.result, trans: n.trans, criteria: { index: null, range: n.range } }))) : a(n) : r.mutate(n) : r.mutate(n) } })); function a(e) { const t = e.trans; t.mutationsAdded = !0; const { txid: n, currentUser: { userId: o } } = t, { type: i } = e, a = ++t.opCount; return r.mutate(e).then((r => { const { numFailures: u, failures: c } = r; let l = "delete" === i ? e.keys : r.results, d = "values" in e ? e.values : [], f = "updates" in e && e.updates; u && (l = l.filter(((e, t) => !c[t])), d = d.filter(((e, t) => !c[t]))); const h = Date.now(), p = "delete" === e.type ? { type: "delete", ts: h, opNo: a, keys: l, criteria: e.criteria, txid: n, userId: o } : "add" === e.type ? { type: "insert", ts: h, opNo: a, keys: l, txid: n, userId: o, values: d } : e.criteria && e.changeSpec ? { type: "modify", ts: h, opNo: a, keys: l, criteria: e.criteria, changeSpec: e.changeSpec, txid: n, userId: o } : f ? { type: "update", ts: h, opNo: a, keys: f.keys, changeSpecs: f.changeSpecs, txid: n, userId: o } : { type: "upsert", ts: h, opNo: a, keys: l, values: d, txid: n, userId: o }; return "isAdditionalChunk" in e && e.isAdditionalChunk && (p.isAdditionalChunk = !0), l.length > 0 || "criteria" in e && e.criteria ? s.mutate({ type: "add", trans: t, values: [p] }).then((() => r)) : r })) } } }) } } }({ currentUserObservable: t.cloud.currentUser, db: br(t) })), t.use((g = br(t), { stack: "dbcore", name: "implicitPropSetterMiddleware", level: 1, create: t => Object.assign(Object.assign({}, t), { table: n => { const r = t.table(n); return Object.assign(Object.assign({}, r), { mutate: t => { var o, i, s, a; if (t.trans.disableChangeTracking) return r.mutate(t); const u = t.trans; if (null === (i = null === (o = g.cloud.schema) || void 0 === o ? void 0 : o[n]) || void 0 === i ? void 0 : i.markedForSync) { if ("versionchange" === u.mode) return Promise.reject(new e.UpgradeError(`Dexie Cloud Addon: Cannot upgrade or populate synced table "${n}". See https://dexie.org/cloud/docs/best-practices`)); if ("add" === t.type || "put" === t.type) { if ("members" === n) for (const e of t.values) "string" == typeof e.email && (e.email = e.email.trim().toLowerCase()); for (const e of t.values) { e.owner || (e.owner = u.currentUser.userId), e.realmId || (e.realmId = u.currentUser.userId); const n = null === (a = (s = r.schema.primaryKey).extractKey) || void 0 === a ? void 0 : a.call(s, e); "string" == typeof n && "#" === n[0] && "put" === t.type && (delete t.criteria, delete t.changeSpec, delete t.updates, e.$ts = Date.now()) } } } return r.mutate(t) } }) } }) })), t.use(function (t) { return { stack: "dbcore", name: "idGenerationMiddleware", level: 1, create: n => Object.assign(Object.assign({}, n), { table: r => { const o = n.table(r); return Object.assign(Object.assign({}, o), { mutate: n => { var i, s; if (n.trans.disableChangeTracking) return o.mutate(n); if ("add" === n.type || "put" === n.type) { const a = null === (i = t.cloud.schema) || void 0 === i ? void 0 : i[r]; if (null == a ? void 0 : a.generatedGlobalId) { if ((null === (s = t.cloud.options) || void 0 === s ? void 0 : s.databaseUrl) && !t.initiallySynced) { const e = Ar(o.schema.primaryKey, n); return o.getMany({ keys: e, trans: n.trans, cache: "immutable" }).then((t => { if (t.length < e.length) throw new Error("Unable to create new objects without an initial sync having been performed."); return o.mutate(n) })) } return function (n, i) { let s = null; const a = Ar(o.schema.primaryKey, n); return a.forEach(((u, c) => { if (void 0 === u) { const r = n.values[c].realmId || t.cloud.currentUserId, u = r.substr(r.length - 3); a[c] = Pr(i, u), o.schema.primaryKey.outbound || (s || (s = n.values.slice()), s[c] = e.deepClone(s[c]), e.setByKeyPath(s[c], o.schema.primaryKey.keyPath, a[c])) } else if ("string" != typeof u || !u.startsWith(i) && !u.startsWith("#" + i)) throw new e.ConstraintError(`The ID "${u}" is not valid for table "${r}". Primary '@' keys requires the key to be prefixed with "${i}" (or "#${i}).\nIf you want to generate IDs programmatically, remove '@' from the schema to get rid of this constraint. Dexie Cloud supports custom IDs as long as they are random and globally unique.`) })), o.mutate(Object.assign(Object.assign({}, n), { keys: a, values: s || n.values })) }(n, a.idPrefix) } (null == a ? void 0 : a.markedForSync) && Ar(o.schema.primaryKey, n).forEach(((t, n) => { if (!Pe(t)) { const n = Array.isArray(t) ? t.map(xr).join(",") : xr(t); throw new e.ConstraintError(`Invalid primary key type ${n} for table ${r}. Tables marked for sync has primary keys of type string or Array of string (and optional numbers)`) } })) } return o.mutate(n) } }) } }) } }(br(t))) } fi.version = "4.0.11", e.Cloud = fi; export { fi as default, fi as dexieCloud, li as getTiedObjectId, ci as getTiedRealmId, Zo as resolveText };
//# sourceMappingURL=/sm/69fdad012b75b84d9e830011d20b88074a37846be67b2fd74e03e735b1bea11c.map